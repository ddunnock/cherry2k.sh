---
phase: 07-file-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/cli/Cargo.toml
  - crates/cli/src/files/mod.rs
  - crates/cli/src/files/reader.rs
  - crates/cli/src/files/detector.rs
  - crates/cli/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can mention a file path in chat and the file content is shown to AI"
    - "User sees a warning when a file is too large to read"
    - "User sees a warning when a file is binary and cannot be read as text"
  artifacts:
    - path: "crates/cli/src/files/mod.rs"
      provides: "File operations module root"
      exports: ["FileReader", "detect_file_references"]
    - path: "crates/cli/src/files/reader.rs"
      provides: "Safe file reading with size limits"
      exports: ["FileReader", "ReadResult"]
    - path: "crates/cli/src/files/detector.rs"
      provides: "File reference detection from messages"
      exports: ["detect_file_references", "is_file_reference"]
  key_links:
    - from: "crates/cli/src/files/detector.rs"
      to: "std::path::Path"
      via: "path existence check"
      pattern: "path\\.is_file\\(\\)|path\\.exists\\(\\)"
    - from: "crates/cli/src/files/reader.rs"
      to: "std::fs"
      via: "file reading"
      pattern: "fs::read_to_string|fs::metadata"
---

<objective>
Implement smart file detection and safe file reading for Phase 7.

Purpose: Enable AI to automatically read files when users mention them in conversation, providing file content as context for AI responses.

Output: File detection and reading modules that can be integrated with the chat command.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-file-operations/07-RESEARCH.md

# Key reference files
@crates/cli/src/lib.rs
@crates/cli/src/confirm.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create files module structure</name>
  <files>
    Cargo.toml
    crates/cli/Cargo.toml
    crates/cli/src/files/mod.rs
    crates/cli/src/lib.rs
  </files>
  <action>
1. Add to workspace Cargo.toml [workspace.dependencies]:
   - walkdir = "2.5"
   - ignore = "0.4"
   - edit = "0.1"

2. Add to crates/cli/Cargo.toml dependencies:
   - walkdir.workspace = true
   - edit.workspace = true

3. Create crates/cli/src/files/mod.rs:
   - Declare submodules: reader, detector
   - Re-export main types: FileReader, ReadResult, detect_file_references

4. Update crates/cli/src/lib.rs:
   - Add `pub mod files;` declaration
  </action>
  <verify>
    cargo check --package cherry2k
  </verify>
  <done>
    Files module exists and compiles, dependencies available
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement file reference detector</name>
  <files>crates/cli/src/files/detector.rs</files>
  <action>
Create detector.rs with smart file reference detection:

1. `detect_file_references(message: &str, cwd: &Path) -> Vec<PathBuf>`:
   - Split message on whitespace, punctuation, and quotes
   - For each potential path token:
     - Try as absolute path (starts with /)
     - Try as relative path (from cwd)
     - Check if path.is_file() returns true
   - Return list of existing file paths found
   - Normalize paths with canonicalize() where possible

2. `is_file_reference(token: &str) -> bool`:
   - Heuristic: contains '/', '.rs', '.ts', '.py', etc.
   - Not just a word like "file" or "main"
   - Has extension or path separator

3. Handle common file path patterns:
   - Quoted paths: "path/to/file.rs"
   - Backticked paths: `path/to/file.rs`
   - Bare paths: path/to/file.rs

4. Tests:
   - "fix main.rs" detects main.rs if exists in cwd
   - "look at src/lib.rs" detects src/lib.rs
   - "what is Rust?" detects nothing
   - Quoted paths detected
   - Non-existent paths filtered out
  </action>
  <verify>
    cargo test --package cherry2k -- files::detector
  </verify>
  <done>
    File detector identifies file references in user messages, tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement safe file reader with size assessment</name>
  <files>crates/cli/src/files/reader.rs</files>
  <action>
Create reader.rs with safe file reading:

1. Constants:
   - LARGE_FILE_THRESHOLD: u64 = 50_000 (50KB - prompt for large files)
   - MAX_FILE_SIZE: u64 = 500_000 (500KB - hard limit)
   - BINARY_CHECK_BYTES: usize = 8192 (check first 8KB for null bytes)

2. `ReadResult` enum:
   - Content(String) - successful read
   - TooLarge { path, size } - exceeds hard limit
   - Binary { path } - detected as binary file
   - Error { path, error } - read failed

3. `FileReader` struct (stateless, just groups functions):
   - `read_file(path: &Path) -> Result<ReadResult, io::Error>`
   - `read_file_unchecked(path: &Path) -> Result<String, io::Error>` (no size check)
   - `check_file_size(path: &Path) -> Result<u64, io::Error>`
   - `is_binary(path: &Path) -> Result<bool, io::Error>` (null byte detection)
   - `is_large(path: &Path) -> Result<bool, io::Error>` (> LARGE_FILE_THRESHOLD)

4. Binary detection heuristic:
   - Read first BINARY_CHECK_BYTES bytes
   - If contains null byte (0x00), treat as binary
   - Common extensions (.png, .jpg, .exe, .bin) also trigger binary

5. Tests:
   - Read small text file -> Content
   - Read file > MAX_FILE_SIZE -> TooLarge
   - Read binary file (create with null bytes in test) -> Binary
   - Read non-existent file -> Error
   - Size threshold detection works
  </action>
  <verify>
    cargo test --package cherry2k -- files::reader
  </verify>
  <done>
    File reader safely reads files with size and binary checks, tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test --package cherry2k -- files::

# Module compiles and exports correctly
cargo check --package cherry2k

# No new warnings
cargo clippy --package cherry2k -- -D warnings
```
</verification>

<success_criteria>
1. `detect_file_references()` finds valid file paths in user messages
2. `FileReader::read_file()` returns appropriate result for text/binary/large files
3. Size thresholds prevent memory issues with large files
4. Binary files detected and handled gracefully (not read as text)
5. All tests pass with `cargo test`
</success_criteria>

<output>
After completion, create `.planning/phases/07-file-operations/07-01-SUMMARY.md`
</output>
