---
phase: 07-file-operations
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - crates/cli/src/files/scope.rs
  - crates/cli/src/files/security.rs
  - crates/cli/src/files/mod.rs
  - crates/cli/src/intent/types.rs
  - crates/cli/src/commands/chat.rs
  - crates/core/src/config/types.rs
  - Cargo.toml
  - crates/cli/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Project root is detected via nearest .git directory"
    - "Files outside project scope trigger extra confirmation warning"
    - "Secrets files (.env, credentials) are blocked from writing"
    - "Path traversal attacks are prevented via canonicalization"
    - "File operations integrate with chat command"
    - "confirm_file_writes config setting is respected"
  artifacts:
    - path: "crates/cli/src/files/scope.rs"
      provides: "Project root detection and scope validation"
      exports: ["ProjectScope", "find_project_root"]
    - path: "crates/cli/src/files/security.rs"
      provides: "Secrets detection and path validation"
      exports: ["is_secrets_file", "validate_write_path"]
  key_links:
    - from: "crates/cli/src/files/scope.rs"
      to: "git2 crate"
      via: "Repository::discover"
      pattern: "Repository::discover"
    - from: "crates/cli/src/files/security.rs"
      to: "std::path::Path"
      via: "path canonicalization"
      pattern: "canonicalize\\(\\)"
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/cli/src/files/mod.rs"
      via: "file context injection"
      pattern: "detect_file_references|FileReader"
---

<objective>
Implement safety controls, scope enforcement, and integrate file operations with the chat command.

Purpose: Ensure file operations respect project boundaries, block secrets files, and work seamlessly within the existing chat flow.

Output: Complete file operations feature with safety controls integrated into the CLI.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-file-operations/07-RESEARCH.md
@.planning/phases/07-file-operations/07-01-SUMMARY.md
@.planning/phases/07-file-operations/07-02-SUMMARY.md

# Key reference files
@crates/cli/src/files/mod.rs
@crates/cli/src/commands/chat.rs
@crates/core/src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add git2 dependency and implement project scope detection</name>
  <files>
    Cargo.toml
    crates/cli/Cargo.toml
    crates/cli/src/files/scope.rs
    crates/cli/src/files/mod.rs
  </files>
  <action>
1. Add to workspace Cargo.toml [workspace.dependencies]:
   - git2 = { version = "0.19", default-features = false }

2. Add to crates/cli/Cargo.toml dependencies:
   - git2.workspace = true

3. Create crates/cli/src/files/scope.rs:

   `find_project_root(start_path: &Path) -> Option<PathBuf>`:
   - Use git2::Repository::discover(start_path)
   - Return repo.workdir().map(|p| p.to_path_buf())
   - Returns None if not in a git repository

   `ProjectScope` struct:
   ```rust
   pub struct ProjectScope {
       /// The project root directory (git working directory or cwd)
       root: PathBuf,
       /// Whether we're in a git repo (vs fallback to cwd)
       is_git_repo: bool,
   }
   ```

   `ProjectScope::detect() -> Result<Self>`:
   - Get cwd
   - Try find_project_root(cwd)
   - If found, use it as root with is_git_repo=true
   - Otherwise, use cwd as root with is_git_repo=false

   `ProjectScope::is_within_scope(&self, path: &Path) -> bool`:
   - Canonicalize the path
   - Check if it starts with self.root
   - Return true if within scope

   `ProjectScope::root(&self) -> &Path`:
   - Return the root path

4. Update crates/cli/src/files/mod.rs:
   - Add `pub mod scope;`
   - Re-export: `ProjectScope`, `find_project_root`

5. Tests:
   - In git repo, finds .git parent as root
   - Outside git repo, uses cwd
   - is_within_scope returns true for files inside root
   - is_within_scope returns false for files outside root
   - Handles symlinks correctly (canonicalize resolves them)
  </action>
  <verify>
    cargo test --package cherry2k -- files::scope
  </verify>
  <done>
    Project scope detection works via git2, tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement secrets detection and path validation</name>
  <files>
    crates/cli/src/files/security.rs
    crates/cli/src/files/mod.rs
  </files>
  <action>
Create security.rs with secrets and path safety checks:

1. Blocked secrets patterns (const array):
   ```rust
   const BLOCKED_FILENAMES: &[&str] = &[
       ".env",
       ".env.local",
       ".env.production",
       ".env.development",
       "credentials.json",
       "secrets.json",
       "secrets.yaml",
       "secrets.yml",
       "id_rsa",
       "id_ed25519",
       "id_ecdsa",
       ".npmrc",
       ".pypirc",
       ".netrc",
       ".aws/credentials",
   ];
   ```

2. `is_secrets_file(path: &Path) -> bool`:
   - Get filename from path
   - Check if filename matches any BLOCKED_FILENAMES
   - Also check if path contains ".aws/credentials" pattern
   - Return true if blocked

3. `ValidationResult` enum:
   - Ok - path is safe to write
   - OutOfScope { path, root } - outside project, needs extra confirmation
   - BlockedSecrets { path } - secrets file, cannot write

4. `validate_write_path(path: &Path, scope: &ProjectScope) -> ValidationResult`:
   - First check is_secrets_file -> BlockedSecrets
   - Canonicalize path (handle non-existent files by canonicalizing parent)
   - Check scope.is_within_scope -> OutOfScope if false
   - Otherwise -> Ok

5. Update crates/cli/src/files/mod.rs:
   - Add `pub mod security;`
   - Re-export: `is_secrets_file`, `validate_write_path`, `ValidationResult`

6. Tests:
   - .env detected as secrets
   - .env.local detected as secrets
   - credentials.json detected as secrets
   - Regular .rs file not blocked
   - Out of scope path returns OutOfScope
   - In scope path returns Ok
   - Secrets file always blocked regardless of scope
  </action>
  <verify>
    cargo test --package cherry2k -- files::security
  </verify>
  <done>
    Security module blocks secrets and validates scope, tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate file operations with chat command</name>
  <files>
    crates/cli/src/intent/types.rs
    crates/cli/src/commands/chat.rs
    crates/core/src/config/types.rs
  </files>
  <action>
1. Update crates/core/src/config/types.rs:
   - Ensure SafetyConfig has `confirm_file_writes: bool` field (should exist from Phase 1)
   - If missing, add it with default true

2. Update crates/cli/src/intent/types.rs:
   - Add FileOperation variant to Intent enum (reserved for future use):
   ```rust
   pub enum Intent {
       Question,
       Command(DetectedCommand),
       // Future: FileOperation for AI-proposed file changes
   }
   ```
   - No changes needed now, but comment documents future extension point

3. Update crates/cli/src/commands/chat.rs to inject file context:

   In the chat flow, before sending to AI:

   a. Detect file references in user message:
   ```rust
   let cwd = std::env::current_dir()?;
   let file_refs = files::detect_file_references(&message, &cwd);
   ```

   b. Read detected files:
   ```rust
   let mut file_context = String::new();
   for path in &file_refs {
       match files::FileReader::read_file(path) {
           Ok(files::ReadResult::Content(content)) => {
               file_context.push_str(&format!(
                   "\n--- File: {} ---\n{}\n",
                   path.display(),
                   content
               ));
           }
           Ok(files::ReadResult::TooLarge { size, .. }) => {
               eprintln!("Skipping {} (too large: {} bytes)", path.display(), size);
           }
           Ok(files::ReadResult::Binary { .. }) => {
               eprintln!("Skipping {} (binary file)", path.display());
           }
           Err(e) => {
               eprintln!("Warning: Could not read {}: {}", path.display(), e);
           }
       }
   }
   ```

   c. Prepend file context to messages sent to AI:
   ```rust
   let augmented_message = if file_context.is_empty() {
       message.clone()
   } else {
       format!(
           "The user referenced these files:\n{}\n\nUser message: {}",
           file_context,
           message
       )
   };
   ```

   d. Log file context injection (tracing::debug):
   ```rust
   if !file_refs.is_empty() {
       tracing::debug!("Injected {} file(s) into context", file_refs.len());
   }
   ```

4. Handle large file confirmation (optional enhancement):
   - If file is large but under MAX_FILE_SIZE, could prompt user
   - For now, just skip with warning (simpler approach)

5. Tests:
   - Integration test: message with file path includes file content in context
   - Binary files skipped with warning
   - Large files skipped with warning
   - Missing files logged but don't fail
  </action>
  <verify>
    cargo test --package cherry2k -- commands::chat
    cargo check --package cherry2k
  </verify>
  <done>
    Chat command injects file context, respects config settings
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test --package cherry2k

# Full compile check
cargo build --package cherry2k

# No warnings
cargo clippy --package cherry2k -- -D warnings

# Manual verification: run with file reference
# echo "test" > /tmp/test.txt
# cargo run -- chat "what's in /tmp/test.txt"
# (should read file and include in context)
```
</verification>

<success_criteria>
1. `ProjectScope::detect()` finds git root or falls back to cwd
2. `is_secrets_file()` blocks .env and credentials files
3. `validate_write_path()` returns appropriate result for all path types
4. Chat command detects file references and injects content into AI context
5. Large and binary files are skipped with user-visible warnings
6. `confirm_file_writes` config setting will gate writes (foundation ready)
7. All tests pass with `cargo test`
</success_criteria>

<output>
After completion, create `.planning/phases/07-file-operations/07-03-SUMMARY.md`
</output>
