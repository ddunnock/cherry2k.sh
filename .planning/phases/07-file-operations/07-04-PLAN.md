---
phase: 07-file-operations
plan: 04
type: execute
wave: 2
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - crates/cli/src/files/proposal.rs
  - crates/cli/src/files/mod.rs
  - crates/cli/src/intent/types.rs
  - crates/cli/src/commands/chat.rs
autonomous: true

must_haves:
  truths:
    - "User sees file write proposals extracted from AI responses"
    - "User can approve or reject each proposed file change"
    - "User can batch-approve multiple file changes with a single confirmation"
    - "Secrets files are blocked from writing with clear error message"
    - "Files outside project scope trigger extra warning before write"
  artifacts:
    - path: "crates/cli/src/files/proposal.rs"
      provides: "AI response parsing to extract file write proposals"
      exports: ["FileProposal", "extract_file_proposals"]
    - path: "crates/cli/src/intent/types.rs"
      provides: "Intent enum with FileOperation variant"
      exports: ["Intent::FileOperation"]
  key_links:
    - from: "crates/cli/src/files/proposal.rs"
      to: "crates/cli/src/files/writer.rs"
      via: "write_file_with_approval for each proposal"
      pattern: "write_file_with_approval\\("
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/cli/src/files/proposal.rs"
      via: "extract_file_proposals after AI response"
      pattern: "extract_file_proposals\\("
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/cli/src/files/security.rs"
      via: "validate_write_path before writing"
      pattern: "validate_write_path\\("
---

<objective>
Integrate AI-proposed file writes into the chat command flow.

Purpose: Complete the file operations feature by enabling AI to propose file changes that are written to disk after user approval. This closes the loop: AI can read files (07-03), propose changes, and write them with user consent.

Output: Chat command detects file write proposals in AI responses and processes them through the approval flow.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-file-operations/07-RESEARCH.md
@.planning/phases/07-file-operations/07-01-SUMMARY.md
@.planning/phases/07-file-operations/07-02-SUMMARY.md
@.planning/phases/07-file-operations/07-03-SUMMARY.md

# Key reference files
@crates/cli/src/files/mod.rs
@crates/cli/src/files/writer.rs
@crates/cli/src/files/security.rs
@crates/cli/src/commands/chat.rs
@crates/cli/src/intent/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement file proposal extraction from AI responses</name>
  <files>
    crates/cli/src/files/proposal.rs
    crates/cli/src/files/mod.rs
  </files>
  <action>
Create proposal.rs to parse AI responses and extract file write proposals:

1. `FileProposal` struct:
   ```rust
   pub struct FileProposal {
       /// Target file path (relative or absolute)
       pub path: PathBuf,
       /// Proposed file content
       pub content: String,
       /// Whether this is a new file (vs edit of existing)
       pub is_new: bool,
   }
   ```

2. `extract_file_proposals(response: &str, cwd: &Path) -> Vec<FileProposal>`:
   Parse AI response for file write proposals using these patterns:

   a. Fenced code blocks with filename:
      ```rust
      // filename: src/main.rs
      fn main() { ... }
      ```
      OR
      ```rust src/main.rs
      fn main() { ... }
      ```

   b. File blocks with explicit markers:
      ```
      --- FILE: src/main.rs ---
      content here
      --- END FILE ---
      ```

   c. Create/write commands in prose:
      "Create a new file `src/main.rs` with the following content:"
      followed by a code block

   Implementation:
   - Use regex to find fenced code blocks: ``` ``` with language and optional filename
   - Extract filename from:
     - Comment like `// filename: path` in first 2 lines of block
     - Inline after language: ```rust path/to/file.rs
     - FILE markers: `--- FILE: path ---`
   - For each extracted block:
     - Resolve path relative to cwd
     - Check if file exists (is_new = !path.exists())
     - Create FileProposal

3. Update crates/cli/src/files/mod.rs:
   - Add `pub mod proposal;`
   - Re-export: `FileProposal`, `extract_file_proposals`

4. Tests:
   - Extract from `// filename: path` comment pattern
   - Extract from inline filename after language tag
   - Extract from FILE markers
   - Multiple proposals in one response
   - Non-file code blocks are ignored (no filename)
   - Relative paths resolved to cwd
   - is_new correctly set based on file existence
  </action>
  <verify>
    cargo test --package cherry2k -- files::proposal
  </verify>
  <done>
    File proposals extracted from AI responses with multiple format support
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FileOperation intent variant</name>
  <files>
    crates/cli/src/intent/types.rs
  </files>
  <action>
Update the Intent enum to include FileOperation:

1. Add FileOperation variant:
   ```rust
   pub enum Intent {
       Question,
       Command(DetectedCommand),
       FileOperation(Vec<FileProposal>),
   }
   ```

2. Add import for FileProposal at top of file:
   ```rust
   use crate::files::FileProposal;
   ```

3. Update any match statements on Intent to handle FileOperation:
   - In display implementations, show "File operation" or similar
   - In any exhaustive matches, add FileOperation arm

This enables the chat command to distinguish between question responses,
command suggestions, and file operation proposals from AI.
  </action>
  <verify>
    cargo check --package cherry2k
    cargo test --package cherry2k -- intent::
  </verify>
  <done>
    Intent enum has FileOperation variant for routing file proposals
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate file write proposals into chat command</name>
  <files>
    crates/cli/src/commands/chat.rs
  </files>
  <action>
Extend chat command to handle file write proposals from AI responses.

Location: AFTER receiving AI response, BEFORE returning to user. Look for where the
response stream is complete and the full response text is available.

1. After AI response is received, check for file proposals:
   ```rust
   let proposals = files::extract_file_proposals(&response_text, &cwd);

   if !proposals.is_empty() {
       tracing::info!("AI proposed {} file change(s)", proposals.len());
       process_file_proposals(&proposals, &scope, config).await?;
   }
   ```

2. Create `process_file_proposals()` helper function:
   ```rust
   async fn process_file_proposals(
       proposals: &[FileProposal],
       scope: &ProjectScope,
       config: &Config,
   ) -> Result<()> {
       use files::{validate_write_path, ValidationResult, write_file_with_approval};

       for proposal in proposals {
           // Validate path first
           match validate_write_path(&proposal.path, scope) {
               ValidationResult::Ok => {
                   // Safe to proceed
               }
               ValidationResult::OutOfScope { path, root } => {
                   eprintln!(
                       "Warning: {} is outside project scope ({})",
                       path.display(),
                       root.display()
                   );
                   // Still allow with extra confirmation via write_file_with_approval
               }
               ValidationResult::BlockedSecrets { path } => {
                   eprintln!(
                       "BLOCKED: Cannot write to secrets file: {}",
                       path.display()
                   );
                   continue; // Skip this proposal entirely
               }
           }

           // Show diff and get approval
           let result = write_file_with_approval(
               &proposal.path,
               &proposal.content,
               !config.safety.confirm_file_writes, // auto_write if confirm disabled
           )?;

           match result {
               WriteResult::Written { path } => {
                   println!("Wrote: {}", path.display());
               }
               WriteResult::Cancelled => {
                   println!("Skipped: {}", proposal.path.display());
               }
               WriteResult::Skipped => {
                   // No changes needed
               }
           }
       }

       Ok(())
   }
   ```

3. For multiple file proposals, add batch handling option:
   - If proposals.len() > 1, first show summary:
     ```
     AI proposes changes to 3 files:
       - src/main.rs (edit)
       - src/lib.rs (new)
       - tests/test.rs (edit)
     ```
   - Then offer: "Review each file? [y/n/all]"
     - y: Step through each file with individual approval
     - n: Cancel all
     - all: Auto-approve all (respects confirm_file_writes config)

4. Initialize ProjectScope early in chat flow:
   ```rust
   let scope = files::ProjectScope::detect()?;
   ```
   Add this near where cwd is established.

5. Tests:
   - Single file proposal extracted and written
   - Multiple file proposals with batch confirmation
   - Secrets file blocked with error message
   - Out-of-scope file shows warning but allows with confirmation
   - confirm_file_writes=false skips approval
  </action>
  <verify>
    cargo test --package cherry2k -- commands::chat
    cargo check --package cherry2k
  </verify>
  <done>
    Chat command processes AI file proposals through approval flow
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test --package cherry2k

# Full compile check
cargo build --package cherry2k

# No warnings
cargo clippy --package cherry2k -- -D warnings

# Manual end-to-end test:
# 1. Ask AI to create a new file
#    cargo run -- chat "create a hello world rust file at /tmp/hello.rs"
# 2. Verify diff/preview is shown
# 3. Approve and verify file was written
# 4. Ask AI to edit an existing file
#    cargo run -- chat "add a goodbye function to /tmp/hello.rs"
# 5. Verify diff shows changes
# 6. Test secrets blocking:
#    cargo run -- chat "create a .env file with API_KEY=test"
#    (should be blocked with error message)
```
</verification>

<success_criteria>
1. `extract_file_proposals()` parses AI responses and finds file write proposals
2. `FileOperation` intent variant routes proposals through correct flow
3. Chat command detects proposals and invokes writer module
4. Secrets files are blocked from writing with clear error
5. Out-of-scope files trigger warning before write
6. Batch approval works for multiple file changes
7. `confirm_file_writes` config setting is respected
8. All tests pass with `cargo test`
</success_criteria>

<output>
After completion, create `.planning/phases/07-file-operations/07-04-SUMMARY.md`
</output>
