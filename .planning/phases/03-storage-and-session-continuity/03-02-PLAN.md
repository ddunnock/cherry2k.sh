---
phase: 03-storage-and-session-continuity
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/storage/src/lib.rs
  - crates/storage/src/session.rs
  - crates/storage/src/message.rs
  - crates/core/src/error.rs
autonomous: true

must_haves:
  truths:
    - "Sessions can be created with auto-generated timestamp IDs"
    - "Sessions are scoped to working directory"
    - "Messages can be saved and retrieved for a session"
    - "Session is auto-continued if last message was within 4 hours"
    - "Sessions older than 30 days are cleaned up"
  artifacts:
    - path: "crates/storage/src/session.rs"
      provides: "Session CRUD operations"
      exports: ["Session", "SessionInfo"]
    - path: "crates/storage/src/message.rs"
      provides: "Message storage and retrieval"
      exports: ["StoredMessage"]
  key_links:
    - from: "crates/storage/src/session.rs"
      to: "crates/storage/src/connection.rs"
      via: "Database.call() for all operations"
      pattern: "db\\.call"
    - from: "crates/storage/src/message.rs"
      to: "crates/storage/src/session.rs"
      via: "Foreign key session_id"
      pattern: "session_id"
---

<objective>
Implement repository layer for sessions and messages with async-safe database access.

Purpose: Provide the data access layer that session management (plan 03) will use. This plan focuses on CRUD operations - no context management or CLI integration yet.

Output: Session and message repository structs with create, read, update, delete operations using tokio-rusqlite's async patterns.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-and-session-continuity/03-RESEARCH.md
@.planning/phases/03-storage-and-session-continuity/03-01-SUMMARY.md

# Relevant codebase files
@crates/storage/src/lib.rs
@crates/storage/src/connection.rs
@crates/storage/src/schema.rs
@crates/core/src/error.rs
@crates/core/src/provider/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session repository</name>
  <files>crates/storage/src/session.rs, crates/storage/src/lib.rs, crates/core/src/error.rs</files>
  <action>
Create crates/storage/src/session.rs with:

**Session struct** (represents a full session record):
```rust
pub struct Session {
    pub id: String,              // Timestamp-based: "2026-01-30-1423-123"
    pub working_dir: String,
    pub created_at: DateTime<Utc>,
    pub last_message_at: DateTime<Utc>,
}
```

**SessionInfo struct** (for list views - lighter weight):
```rust
pub struct SessionInfo {
    pub id: String,
    pub created_at: DateTime<Utc>,
    pub last_message_at: DateTime<Utc>,
    pub first_message_preview: Option<String>,  // First 100 chars of first message
}
```

**Functions operating on Database:**

1. `generate_session_id() -> String` - Creates timestamp-based ID with milliseconds for uniqueness: "YYYY-MM-DD-HHMM-SSS"

2. `create_session(db: &Database, working_dir: &Path) -> Result<String, StorageError>` - Inserts new session, returns ID

3. `get_or_create_session(db: &Database, working_dir: &Path) -> Result<String, StorageError>` - Returns existing session in same directory if last_message_at < 4 hours ago, otherwise creates new

4. `get_session(db: &Database, session_id: &str) -> Result<Option<Session>, StorageError>` - Retrieves session by ID

5. `list_sessions(db: &Database, working_dir: &Path, limit: usize) -> Result<Vec<SessionInfo>, StorageError>` - Lists sessions for directory with first message preview, ordered by last_message_at DESC

6. `update_session_timestamp(db: &Database, session_id: &str) -> Result<(), StorageError>` - Updates last_message_at to now

7. `delete_session(db: &Database, session_id: &str) -> Result<(), StorageError>` - Deletes session and cascades to messages

8. `cleanup_old_sessions(db: &Database) -> Result<usize, StorageError>` - Deletes sessions older than 30 days, returns count deleted

Use rusqlite::params![] macro for parameter binding. All functions use db.call() with closures.

Update crates/core/src/error.rs - add From<rusqlite::Error> for StorageError::Database variant.

Update crates/storage/src/lib.rs to declare session module and re-export Session, SessionInfo, and the functions.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/cherry2k && cargo test -p cherry2k-storage session
```
Session tests pass.
  </verify>
  <done>
- Session and SessionInfo structs exist with all fields
- All 8 session functions implemented and tested
- 4-hour idle timeout logic works correctly
- 30-day cleanup removes old sessions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement message repository</name>
  <files>crates/storage/src/message.rs, crates/storage/src/lib.rs</files>
  <action>
Create crates/storage/src/message.rs with:

**StoredMessage struct**:
```rust
pub struct StoredMessage {
    pub id: i64,
    pub session_id: String,
    pub role: Role,              // Reuse from cherry2k_core::provider::Role
    pub content: String,
    pub token_count: Option<i64>,
    pub is_summary: bool,
    pub created_at: DateTime<Utc>,
}
```

Note: Reuse Role enum from cherry2k_core::provider::types. Add cherry2k-core as dependency if not already.

**Functions operating on Database:**

1. `save_message(db: &Database, session_id: &str, role: Role, content: &str, token_count: Option<i64>) -> Result<i64, StorageError>` - Inserts message, updates session timestamp, returns message ID. Use transaction for atomicity.

2. `save_summary(db: &Database, session_id: &str, summary_content: &str) -> Result<i64, StorageError>` - Inserts message with is_summary=true, role=System

3. `get_messages(db: &Database, session_id: &str) -> Result<Vec<StoredMessage>, StorageError>` - Retrieves all messages for session, ordered by created_at ASC

4. `get_messages_since(db: &Database, session_id: &str, since: DateTime<Utc>) -> Result<Vec<StoredMessage>, StorageError>` - Retrieves messages after given timestamp

5. `count_messages(db: &Database, session_id: &str) -> Result<i64, StorageError>` - Returns message count for session

6. `delete_messages_before(db: &Database, session_id: &str, before_id: i64) -> Result<usize, StorageError>` - Deletes messages with id < before_id (used after summarization), returns count deleted

Transaction pattern for save_message:
```rust
db.call(move |conn| {
    let tx = conn.transaction()?;
    // Insert message
    // Update session timestamp
    tx.commit()?;
    Ok(message_id)
}).await
```

Role serialization: Store as lowercase string ("user", "assistant", "system"). Parse on retrieval.

Update crates/storage/src/lib.rs to declare message module and re-export StoredMessage and the functions.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/cherry2k && cargo test -p cherry2k-storage message
```
Message tests pass.
  </verify>
  <done>
- StoredMessage struct exists with all fields
- All 6 message functions implemented and tested
- save_message uses transaction for atomicity
- Role correctly serializes/deserializes
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/dunnock/projects/cherry2k
cargo check -p cherry2k-storage
cargo test -p cherry2k-storage
cargo clippy -p cherry2k-storage -- -D warnings
```

Integration test: Create session, save messages, retrieve messages, verify data integrity.
</verification>

<success_criteria>
1. All session CRUD operations work correctly
2. All message CRUD operations work correctly
3. Transactions used for multi-statement operations
4. 4-hour session continuity works as specified
5. 30-day cleanup deletes old sessions
6. Role enum correctly stored and retrieved
</success_criteria>

<output>
After completion, create `.planning/phases/03-storage-and-session-continuity/03-02-SUMMARY.md`
</output>
