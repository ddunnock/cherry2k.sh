---
phase: 03-storage-and-session-continuity
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - crates/storage/src/lib.rs
  - crates/storage/src/context.rs
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
  - crates/cli/src/commands/mod.rs
  - crates/cli/src/commands/chat.rs
  - crates/cli/src/commands/session.rs
autonomous: true

must_haves:
  truths:
    - "User can have multi-turn conversation with context retained"
    - "Conversation persists after terminal closes"
    - "User can resume session with cherry2k resume"
    - "User can list sessions with cherry2k resume --list"
    - "Context is summarized when approaching token limit"
    - "Summarization indicator shown when context compressed"
  artifacts:
    - path: "crates/storage/src/context.rs"
      provides: "Context window management with summarization"
      exports: ["ContextManager", "prepare_context"]
    - path: "crates/cli/src/commands/session.rs"
      provides: "Session CLI commands (resume, new, clear)"
      exports: ["resume", "new_session", "clear"]
    - path: "crates/cli/src/commands/chat.rs"
      provides: "Chat command with session integration"
      contains: "save_message"
  key_links:
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/storage/src/session.rs"
      via: "get_or_create_session on each chat"
      pattern: "get_or_create_session"
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/storage/src/message.rs"
      via: "save_message after response"
      pattern: "save_message"
    - from: "crates/storage/src/context.rs"
      to: "cherry2k_core::AiProvider"
      via: "complete() for summarization"
      pattern: "provider\\.complete"
---

<objective>
Integrate session management into chat command and implement context window handling with LLM-based summarization.

Purpose: Complete the storage phase by wiring storage layer to CLI. Users can now have multi-turn conversations that persist and resume.

Output: Chat command uses sessions automatically, resume/new/clear commands available, context summarization prevents token overflow.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-and-session-continuity/03-RESEARCH.md
@.planning/phases/03-storage-and-session-continuity/03-01-SUMMARY.md
@.planning/phases/03-storage-and-session-continuity/03-02-SUMMARY.md

# Relevant codebase files
@crates/cli/src/main.rs
@crates/cli/src/commands/chat.rs
@crates/cli/src/commands/mod.rs
@crates/storage/src/lib.rs
@crates/core/src/provider/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement context window management</name>
  <files>crates/storage/src/context.rs, crates/storage/src/lib.rs</files>
  <action>
Create crates/storage/src/context.rs with:

**Constants:**
```rust
const TOKEN_BUDGET: usize = 16_000;      // Max tokens for conversation history
const SUMMARIZE_THRESHOLD: f32 = 0.75;   // Trigger summarization at 75%
const CHARS_PER_TOKEN: usize = 4;        // Conservative estimate
```

**SUMMARIZATION_PROMPT:**
```rust
const SUMMARIZATION_PROMPT: &str = r#"Summarize the following conversation history, preserving:
- Key facts and decisions made
- User's goals and preferences
- Unresolved questions or issues
- Technical context (file paths, commands, errors)

Be concise but preserve critical context. The summary will replace these messages.

Conversation:
{conversation}

Summary:"#;
```

**ContextResult struct:**
```rust
pub struct ContextResult {
    pub messages: Vec<Message>,      // Messages to send to provider
    pub was_summarized: bool,        // True if summarization occurred
}
```

**Functions:**

1. `estimate_tokens(messages: &[StoredMessage]) -> usize` - Estimates token count using chars/4 heuristic. Simple but sufficient for Phase 03.

2. `prepare_context(db: &Database, session_id: &str, provider: &impl AiProvider) -> Result<ContextResult, StorageError>` - Main entry point:
   - Load all messages for session
   - If estimate < 75% of TOKEN_BUDGET, return messages as-is with was_summarized=false
   - If over threshold:
     1. Split messages at 50% point
     2. Format old messages for summarization
     3. Call provider.complete() with summarization prompt
     4. Collect summary stream to string
     5. Delete old messages from DB
     6. Save summary as system message with is_summary=true
     7. Return remaining messages + summary, was_summarized=true

3. `format_for_summary(messages: &[StoredMessage]) -> String` - Formats messages as "Role: content\n\n" for summarization prompt

**Important:** Make prepare_context generic over AiProvider so it works with any provider. The summarization uses the same provider as the chat.

Update crates/storage/src/lib.rs to declare context module and re-export ContextResult and prepare_context.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/cherry2k && cargo test -p cherry2k-storage context
```
Context tests pass.
  </verify>
  <done>
- Token estimation works with conservative 4 chars/token
- Summarization triggers at 75% of 16K budget
- Old messages deleted after summarization
- Summary saved with is_summary=true flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session commands to CLI</name>
  <files>crates/cli/Cargo.toml, crates/cli/src/main.rs, crates/cli/src/commands/mod.rs, crates/cli/src/commands/session.rs</files>
  <action>
Update crates/cli/Cargo.toml to add cherry2k-storage dependency:
```toml
cherry2k-storage = { path = "../storage" }
```

Create crates/cli/src/commands/session.rs with:

**resume command:**
```rust
pub async fn resume(db: &Database, session_id: Option<&str>, list: bool) -> Result<()>
```
- If list=true: Call list_sessions() for current directory, display table with ID, date, first message preview (truncated to 50 chars)
- If session_id provided: Validate session exists, print "Resumed session {id}"
- If neither: Get most recent session in current dir, print "Resumed session {id}" or "No sessions found in this directory"

**new_session command:**
```rust
pub async fn new_session(db: &Database) -> Result<()>
```
- Force create new session in current directory
- Print "Created new session {id}"

**clear command:**
```rust
pub async fn clear(db: &Database) -> Result<()>
```
- Prompt user "Delete all sessions? [y/n]: " using existing confirm pattern
- If yes: Delete all sessions (across all directories), print "Deleted {n} sessions"
- If no: Print "Cancelled"

Update crates/cli/src/commands/mod.rs to declare session module.

Update crates/cli/src/main.rs to add subcommands:
```rust
#[derive(Subcommand)]
enum Commands {
    Chat { ... },
    Config { ... },
    Resume {
        #[arg(long)]
        list: bool,
        session_id: Option<String>,
    },
    New,
    Clear,
}
```

Wire up command handlers in main().
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/cherry2k && cargo build -p cherry2k-cli
./target/debug/cherry2k resume --help
./target/debug/cherry2k new --help
./target/debug/cherry2k clear --help
```
Commands show help text.
  </verify>
  <done>
- cherry2k resume lists or resumes sessions
- cherry2k new forces new session
- cherry2k clear deletes all sessions with confirmation
- All commands work with XDG database path
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate sessions into chat command</name>
  <files>crates/cli/src/commands/chat.rs</files>
  <action>
Update crates/cli/src/commands/chat.rs to:

1. **Open database at start:**
```rust
let db = Database::open().await
    .context("Failed to open session database")?;
```

2. **Get or create session:**
```rust
let session_id = get_or_create_session(&db, &std::env::current_dir()?)
    .await
    .context("Failed to get session")?;
```

3. **Load conversation history:**
```rust
let context = prepare_context(&db, &session_id, &provider)
    .await
    .context("Failed to load conversation history")?;

// Show indicator if summarization occurred
if context.was_summarized {
    println!("(context summarized)");
}
```

4. **Build request with history:**
```rust
let request = CompletionRequest::new()
    .with_messages(context.messages.into_iter().map(|m| Message::new(m.role, m.content)))
    .with_message(Message::user(message));
```

5. **Save user message before request:**
```rust
save_message(&db, &session_id, Role::User, message, None)
    .await
    .context("Failed to save message")?;
```

6. **Collect and save assistant response:**
After streaming completes, collect the full response text and save:
```rust
save_message(&db, &session_id, Role::Assistant, &response_text, None)
    .await
    .context("Failed to save response")?;
```

7. **Run cleanup on startup:**
At start of chat, call `cleanup_old_sessions(&db)` to remove 30-day old sessions. Log count if > 0 for debugging.

**Important flow changes:**
- The StreamWriter needs to accumulate the full response for saving
- Add a `collected_response: String` that gets appended to in the stream loop
- Use this for the save_message call at the end
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/cherry2k
cargo build -p cherry2k-cli

# Test multi-turn conversation
export OPENAI_API_KEY=...
./target/debug/cherry2k chat "Remember my name is Alice"
./target/debug/cherry2k chat "What is my name?"
# Should respond with "Alice"

# Verify persistence
./target/debug/cherry2k resume --list
# Should show session with messages
```
  </verify>
  <done>
- Chat automatically continues session in same directory
- Conversation history sent to provider
- User and assistant messages saved to database
- Context summarization triggers when needed
- "(context summarized)" indicator shown when compression occurs
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/dunnock/projects/cherry2k
cargo check --workspace
cargo test --workspace
cargo clippy --workspace -- -D warnings

# Integration test with real API (requires OPENAI_API_KEY)
./target/debug/cherry2k chat "Remember the secret code is 42"
./target/debug/cherry2k chat "What is the secret code?"
# Second response should mention "42"

./target/debug/cherry2k resume --list
# Should show session

./target/debug/cherry2k new
./target/debug/cherry2k chat "Hello"
./target/debug/cherry2k resume --list
# Should show two sessions
```
</verification>

<success_criteria>
1. Multi-turn conversations work with context retention
2. Sessions persist after terminal closes (verified by resume --list)
3. cherry2k resume continues most recent session
4. cherry2k new creates fresh session
5. cherry2k clear deletes sessions with confirmation
6. Context summarization triggers at token threshold
7. All workspace tests pass
8. No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-storage-and-session-continuity/03-03-SUMMARY.md`
</output>
