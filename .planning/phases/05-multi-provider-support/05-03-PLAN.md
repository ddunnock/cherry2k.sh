---
phase: 05-multi-provider-support
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - crates/core/src/provider/factory.rs
  - crates/core/src/provider/mod.rs
  - crates/core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "ProviderFactory::from_config creates providers from Config"
    - "ProviderFactory::get returns provider by name"
    - "ProviderFactory::list returns all configured providers"
    - "Missing provider config skips registration (no error)"
    - "default_provider from config is validated"
  artifacts:
    - path: "crates/core/src/provider/factory.rs"
      provides: "Provider factory and registry"
      exports: ["ProviderFactory"]
      min_lines: 80
  key_links:
    - from: "crates/core/src/provider/factory.rs"
      to: "Box<dyn AiProvider>"
      via: "HashMap storage"
      pattern: "HashMap<String, Box<dyn AiProvider>>"
---

<objective>
Create ProviderFactory for dynamic provider registration and lookup.

Purpose: Enable runtime provider switching and multi-provider management, supporting PROV-04 requirement.
Output: `ProviderFactory` struct that registers all configured providers and provides lookup by name.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-provider-support/05-RESEARCH.md

# Provider implementations
@crates/core/src/provider/trait.rs
@crates/core/src/provider/openai.rs
@crates/core/src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProviderFactory</name>
  <files>crates/core/src/provider/factory.rs</files>
  <action>
Create `ProviderFactory` struct for provider registration and lookup.

**Structure:**
```rust
use std::collections::HashMap;
use super::{AiProvider, AnthropicProvider, OllamaProvider, OpenAiProvider};
use crate::config::Config;
use crate::error::ConfigError;

/// Factory for creating and managing AI providers.
///
/// Registers providers based on configuration and provides lookup by name.
pub struct ProviderFactory {
    providers: HashMap<String, Box<dyn AiProvider>>,
    default_provider: String,
}
```

**Implementation:**

1. **`from_config(config: &Config) -> Result<Self, ConfigError>`**
   - Create empty HashMap
   - For each provider config that exists (is Some):
     - Create provider instance
     - Call `validate_config()` - if fails, log warning but continue (per CONTEXT.md: "Invalid key: warn and continue")
     - If validation passes, register in HashMap
   - Validate that `config.general.default_provider` exists in registered providers
   - If default_provider not found and no providers registered: return ConfigError
   - If default_provider not found but others exist: log warning, pick first available

   ```rust
   pub fn from_config(config: &Config) -> Result<Self, ConfigError> {
       let mut providers: HashMap<String, Box<dyn AiProvider>> = HashMap::new();

       // Register OpenAI if configured
       if let Some(ref cfg) = config.openai {
           let provider = OpenAiProvider::new(cfg.clone());
           if let Err(e) = provider.validate_config() {
               tracing::warn!("OpenAI config invalid: {e}");
           } else {
               providers.insert("openai".to_string(), Box::new(provider));
           }
       }

       // Register Anthropic if configured
       if let Some(ref cfg) = config.anthropic {
           let provider = AnthropicProvider::new(cfg.clone());
           if let Err(e) = provider.validate_config() {
               tracing::warn!("Anthropic config invalid: {e}");
           } else {
               providers.insert("anthropic".to_string(), Box::new(provider));
           }
       }

       // Register Ollama if configured
       if let Some(ref cfg) = config.ollama {
           let provider = OllamaProvider::new(cfg.clone());
           if let Err(e) = provider.validate_config() {
               tracing::warn!("Ollama config invalid: {e}");
           } else {
               providers.insert("ollama".to_string(), Box::new(provider));
           }
       }

       // Validate we have at least one provider
       if providers.is_empty() {
           return Err(ConfigError::MissingField {
               field: "No providers configured. Set OPENAI_API_KEY, ANTHROPIC_API_KEY, or configure Ollama.".to_string(),
           });
       }

       // Validate default_provider exists
       let default_provider = config.general.default_provider.clone();
       if !providers.contains_key(&default_provider) {
           let available = providers.keys().next().unwrap().clone();
           tracing::warn!(
               "Default provider '{}' not available, using '{}'",
               default_provider,
               available
           );
           return Ok(Self {
               providers,
               default_provider: available,
           });
       }

       Ok(Self {
           providers,
           default_provider,
       })
   }
   ```

2. **`get(&self, name: &str) -> Option<&dyn AiProvider>`**
   - Return provider by name or None if not found
   ```rust
   pub fn get(&self, name: &str) -> Option<&dyn AiProvider> {
       self.providers.get(name).map(|p| p.as_ref())
   }
   ```

3. **`get_default(&self) -> &dyn AiProvider`**
   - Return the default provider (guaranteed to exist after from_config succeeds)
   ```rust
   pub fn get_default(&self) -> &dyn AiProvider {
       self.providers.get(&self.default_provider).unwrap().as_ref()
   }
   ```

4. **`default_provider_name(&self) -> &str`**
   - Return the name of the default provider
   ```rust
   pub fn default_provider_name(&self) -> &str {
       &self.default_provider
   }
   ```

5. **`list(&self) -> Vec<&str>`**
   - Return sorted list of registered provider names
   ```rust
   pub fn list(&self) -> Vec<&str> {
       let mut names: Vec<_> = self.providers.keys().map(|s| s.as_str()).collect();
       names.sort();
       names
   }
   ```

6. **`contains(&self, name: &str) -> bool`**
   - Check if a provider is registered
   ```rust
   pub fn contains(&self, name: &str) -> bool {
       self.providers.contains_key(name)
   }
   ```

**Tests:**
- `from_config_with_openai_only()` - single provider works
- `from_config_with_multiple_providers()` - multiple providers registered
- `from_config_no_providers_fails()` - empty config returns error
- `get_returns_provider()` - lookup works
- `get_unknown_returns_none()` - unknown name returns None
- `list_returns_all_providers()` - all registered names returned
- `default_provider_fallback()` - uses first available when default missing
  </action>
  <verify>
```bash
cargo check -p cherry2k-core 2>&1 | head -20
cargo test -p cherry2k-core factory 2>&1 | tail -30
```
  </verify>
  <done>ProviderFactory compiles, registers providers from config, all unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Export ProviderFactory from module and crate</name>
  <files>crates/core/src/provider/mod.rs, crates/core/src/lib.rs</files>
  <action>
**Update crates/core/src/provider/mod.rs:**

1. Add module declaration: `mod factory;`
2. Add public re-export: `pub use factory::ProviderFactory;`

**Update crates/core/src/lib.rs:**

Add `ProviderFactory` to the provider re-exports:
```rust
pub use provider::{
    AiProvider, CompletionRequest, CompletionStream, Message, OpenAiProvider,
    AnthropicProvider, OllamaProvider, ProviderFactory, Role,
};
```
  </action>
  <verify>
```bash
cargo check -p cherry2k-core 2>&1 | head -10
```
  </verify>
  <done>ProviderFactory is exported from cherry2k_core crate root</done>
</task>

</tasks>

<verification>
```bash
# Full check
cargo check -p cherry2k-core
cargo clippy -p cherry2k-core -- -D warnings
cargo test -p cherry2k-core factory

# Verify export
cargo doc -p cherry2k-core --no-deps 2>&1 | grep -i factory
```
</verification>

<success_criteria>
- ProviderFactory builds HashMap from Config
- Invalid configs warn but don't block other providers
- get() and list() work correctly
- Default provider fallback works when configured default unavailable
- All unit tests pass
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-provider-support/05-03-SUMMARY.md`
</output>
