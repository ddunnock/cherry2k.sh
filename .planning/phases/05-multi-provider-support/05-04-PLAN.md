---
phase: 05-multi-provider-support
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - crates/cli/src/commands/chat.rs
  - crates/cli/src/commands/provider.rs
  - crates/cli/src/commands/mod.rs
  - crates/cli/src/main.rs
  - zsh/cherry2k.plugin.zsh
autonomous: true

must_haves:
  truths:
    - "chat command uses ProviderFactory and respects default_provider"
    - "/provider <name> command switches provider in-session"
    - "/providers command lists available providers"
    - "/provider (no args) shows current provider and model"
    - "* /provider anthropic works from zsh inline mode"
  artifacts:
    - path: "crates/cli/src/commands/provider.rs"
      provides: "Provider switching CLI commands"
      exports: ["run_switch", "run_list", "run_current"]
      min_lines: 60
  key_links:
    - from: "crates/cli/src/commands/chat.rs"
      to: "ProviderFactory"
      via: "factory.get() or factory.get_default()"
      pattern: "ProviderFactory::from_config"
    - from: "zsh/cherry2k.plugin.zsh"
      to: "cherry2k provider"
      via: "slash command detection"
      pattern: "/provider"
---

<objective>
Integrate ProviderFactory into CLI and add provider switching commands.

Purpose: Enable users to switch providers via config or in-session commands, fulfilling PROV-04 requirement.
Output: Updated chat command using factory, new `/provider` commands, zsh integration for slash commands.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-provider-support/05-CONTEXT.md

# Existing CLI structure
@crates/cli/src/main.rs
@crates/cli/src/commands/chat.rs
@crates/cli/src/commands/mod.rs

# Zsh integration
@zsh/cherry2k.plugin.zsh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider commands module</name>
  <files>crates/cli/src/commands/provider.rs</files>
  <action>
Create CLI handlers for provider management commands.

**Commands to implement:**

1. **`run_list(config: &Config)`** - Show all configured providers
   - Create ProviderFactory from config
   - List all registered providers
   - Mark which one is active (default)
   - Format:
     ```
     Available providers:
       * anthropic (claude-sonnet-4-20250514) [active]
         ollama (llama3.2)
         openai (gpt-4o)
     ```

2. **`run_current(config: &Config)`** - Show current provider and model
   - Format: `Currently using: anthropic (claude-sonnet-4-20250514)`

3. **`run_switch(config: &Config, provider_name: &str)`** - Switch to provider
   - Validate provider exists in factory
   - If not exists: show error and list available
   - If exists: confirm switch (no dialog per CONTEXT.md, just message)
   - Format: `Switched to: anthropic (claude-sonnet-4-20250514)`

   **Important:** In-session switching needs state persistence. For now, use environment variable approach:
   - Write selected provider to a state file: `~/.local/state/cherry2k/active_provider`
   - Chat command reads this file to override default_provider
   - Fresh sessions start with config's default_provider

**State file handling:**
```rust
use directories::ProjectDirs;
use std::fs;

fn get_state_dir() -> Option<std::path::PathBuf> {
    ProjectDirs::from("", "", "cherry2k")
        .map(|dirs| dirs.state_dir().unwrap_or(dirs.data_dir()).to_path_buf())
}

fn get_active_provider() -> Option<String> {
    let state_dir = get_state_dir()?;
    let path = state_dir.join("active_provider");
    fs::read_to_string(&path).ok().map(|s| s.trim().to_string())
}

fn set_active_provider(name: &str) -> Result<()> {
    let state_dir = get_state_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not determine state directory"))?;
    fs::create_dir_all(&state_dir)?;
    fs::write(state_dir.join("active_provider"), name)?;
    Ok(())
}

fn clear_active_provider() -> Result<()> {
    if let Some(state_dir) = get_state_dir() {
        let path = state_dir.join("active_provider");
        if path.exists() {
            fs::remove_file(path)?;
        }
    }
    Ok(())
}
```

**Helper function to get model for provider:**
```rust
fn get_model_for_provider(config: &Config, provider: &str) -> String {
    match provider {
        "openai" => config.openai.as_ref().map(|c| c.model.clone()),
        "anthropic" => config.anthropic.as_ref().map(|c| c.model.clone()),
        "ollama" => config.ollama.as_ref().map(|c| c.model.clone()),
        _ => None,
    }.unwrap_or_else(|| "unknown".to_string())
}
```

**Error handling:**
- Unknown provider: "Provider 'foo' not configured. Available: anthropic, ollama, openai"
- No providers: "No providers configured. Set OPENAI_API_KEY, ANTHROPIC_API_KEY, or configure Ollama."
  </action>
  <verify>
```bash
cargo check -p cherry2k-cli 2>&1 | head -20
```
  </verify>
  <done>Provider commands module compiles with list, current, switch functions</done>
</task>

<task type="auto">
  <name>Task 2: Update chat command to use ProviderFactory</name>
  <files>crates/cli/src/commands/chat.rs</files>
  <action>
Update chat.rs to use ProviderFactory instead of hardcoded OpenAiProvider.

**Changes:**

1. **Import ProviderFactory:**
   ```rust
   use cherry2k_core::ProviderFactory;
   ```
   Remove: `use cherry2k_core::OpenAiProvider;`

2. **Replace provider creation logic:**

   Old code (around line 132-141):
   ```rust
   // Get OpenAI config or error
   let openai_config = config.openai.clone().ok_or_else(|| {
       anyhow::anyhow!("OpenAI not configured. Set OPENAI_API_KEY environment variable.")
   })?;

   // Create and validate provider
   let provider = OpenAiProvider::new(openai_config);
   provider
       .validate_config()
       .context("Invalid OpenAI configuration")?;
   ```

   New code:
   ```rust
   // Create provider factory from config
   let factory = ProviderFactory::from_config(config)
       .context("Failed to initialize providers")?;

   // Check for in-session provider override
   let active_provider_name = super::provider::get_active_provider()
       .filter(|name| factory.contains(name))
       .unwrap_or_else(|| factory.default_provider_name().to_string());

   let provider = factory.get(&active_provider_name)
       .ok_or_else(|| anyhow::anyhow!("Provider '{}' not available", active_provider_name))?;

   tracing::debug!("Using provider: {}", provider.provider_id());
   ```

3. **Update context preparation call:**
   The `prepare_context` function takes `&impl AiProvider`, which works with `&dyn AiProvider`.
   No change needed for this line.

4. **Error display remains the same** - ProviderError variants are unchanged.

**Important:** The session clearing mentioned in CONTEXT.md ("Fresh start on provider switch") is natural behavior - each provider doesn't share conversation history. The session is per-directory, and messages reference the provider they were sent to. For Phase 5, we simply use the current provider; cross-provider conversation history is out of scope.
  </action>
  <verify>
```bash
cargo check -p cherry2k-cli 2>&1 | head -20
```
  </verify>
  <done>Chat command uses ProviderFactory, respects active_provider state</done>
</task>

<task type="auto">
  <name>Task 3: Add CLI commands and slash command detection</name>
  <files>crates/cli/src/commands/mod.rs, crates/cli/src/main.rs, zsh/cherry2k.plugin.zsh</files>
  <action>
**Update crates/cli/src/commands/mod.rs:**
```rust
pub mod chat;
pub mod config;
pub mod provider;
pub mod session;
```

**Update crates/cli/src/main.rs:**

1. Add new Commands variants:
   ```rust
   #[derive(Subcommand)]
   enum Commands {
       // ... existing commands ...

       /// Show or switch providers
       Provider {
           /// Provider to switch to (omit to show current)
           name: Option<String>,
           /// List all available providers
           #[arg(short, long)]
           list: bool,
       },
   }
   ```

2. Add command handler in match:
   ```rust
   Commands::Provider { name, list } => {
       if list {
           commands::provider::run_list(&config)?;
       } else if let Some(provider_name) = name {
           commands::provider::run_switch(&config, &provider_name)?;
       } else {
           commands::provider::run_current(&config)?;
       }
   }
   ```

**Update zsh/cherry2k.plugin.zsh:**

Add slash command detection in the `_cherry2k_ai_request` function (or create if needed).

Find where the input is processed and add detection for `/provider` and `/providers`:

```zsh
# Detect slash commands
_cherry2k_handle_slash_command() {
    local input="$1"

    case "$input" in
        /provider)
            cherry2k provider
            return 0
            ;;
        /provider\ *)
            local provider_name="${input#/provider }"
            cherry2k provider "$provider_name"
            return 0
            ;;
        /providers)
            cherry2k provider --list
            return 0
            ;;
        /model)
            # TODO: Phase 5 extension - model switching
            echo "Model switching not yet implemented"
            return 0
            ;;
        /model\ *)
            echo "Model switching not yet implemented"
            return 0
            ;;
        /models)
            echo "Model listing not yet implemented"
            return 0
            ;;
        *)
            return 1  # Not a slash command
            ;;
    esac
}
```

Then in `_cherry2k_process_input` (or equivalent), before sending to AI:
```zsh
# Check for slash commands first
if _cherry2k_handle_slash_command "$input"; then
    return 0
fi

# Not a slash command, proceed with AI request
cherry2k chat "$input" --context-file "$context_file"
```

**Location in cherry2k.plugin.zsh:**
Look for the `_cherry2k_ai_mode_accept` function or similar that handles `* ` prefix input.
Add slash command detection before the `cherry2k chat` call.
  </action>
  <verify>
```bash
cargo build -p cherry2k-cli 2>&1 | head -10
# Test CLI
./target/debug/cherry2k provider --help
./target/debug/cherry2k provider --list 2>&1 | head -5
```
  </verify>
  <done>CLI has provider command, zsh detects /provider slash commands</done>
</task>

</tasks>

<verification>
```bash
# Build and test CLI
cargo build -p cherry2k-cli
./target/debug/cherry2k provider --list
./target/debug/cherry2k provider
./target/debug/cherry2k provider openai  # If openai configured

# Full test suite
cargo test -p cherry2k-cli
cargo clippy -- -D warnings
```
</verification>

<success_criteria>
- `cherry2k provider --list` shows all configured providers
- `cherry2k provider` shows current provider and model
- `cherry2k provider <name>` switches provider
- Chat command uses ProviderFactory, respects switched provider
- Zsh `/provider` slash commands work
- All tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-provider-support/05-04-SUMMARY.md`
</output>
