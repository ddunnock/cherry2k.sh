---
phase: 06-command-execution-flow
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - crates/cli/src/output/command_display.rs
  - crates/cli/src/output/mod.rs
  - crates/cli/src/confirm.rs
autonomous: true

must_haves:
  truths:
    - "Suggested commands display with bash syntax highlighting"
    - "User sees [y/n/e] confirmation prompt"
    - "Edit option allows modifying command before execution"
  artifacts:
    - path: "crates/cli/src/output/command_display.rs"
      provides: "Command display with syntax highlighting"
      exports: ["display_suggested_command"]
    - path: "crates/cli/src/confirm.rs"
      provides: "Enhanced confirm_command with edit flow"
  key_links:
    - from: "command_display.rs"
      to: "termimad"
      via: "bash code block rendering"
      pattern: "MadSkin|print_inline"
---

<objective>
Enhance command presentation with syntax highlighting and implement the edit flow for command confirmation.

Purpose: Present AI-suggested commands clearly with bash syntax highlighting, and enable users to edit commands before execution via the (e)dit option.

Output: Command display module and enhanced confirmation flow.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-command-execution-flow/06-CONTEXT.md
@.planning/phases/06-command-execution-flow/06-RESEARCH.md
@crates/cli/src/output/mod.rs
@crates/cli/src/confirm.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command display with syntax highlighting</name>
  <files>crates/cli/src/output/command_display.rs, crates/cli/src/output/mod.rs</files>
  <action>
Create command_display.rs:

```rust
//! Command display with syntax highlighting
//!
//! Displays suggested commands in a formatted code block with bash
//! syntax highlighting for improved readability.

use termimad::MadSkin;

/// Display a suggested command with bash syntax highlighting.
///
/// Renders the command in a formatted code block using termimad's
/// markdown rendering, which provides syntax highlighting for bash.
///
/// If context text is provided (explanation before the command),
/// it is displayed first.
///
/// # Arguments
/// * `command` - The command string to display
/// * `context` - Optional context/explanation text
pub fn display_suggested_command(command: &str, context: Option<&str>) {
    let skin = MadSkin::default();

    // Display context if provided
    if let Some(ctx) = context {
        if !ctx.is_empty() {
            println!();
            skin.print_text(ctx);
        }
    }

    // Format as markdown code block
    let markdown = format!("\n```bash\n{}\n```\n", command);
    skin.print_text(&markdown);
}
```

Update output/mod.rs to export:
```rust
mod command_display;
pub use command_display::display_suggested_command;
```
  </action>
  <verify>cargo check -p cherry2k</verify>
  <done>Command display with syntax highlighting compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement edit command flow</name>
  <files>crates/cli/src/confirm.rs</files>
  <action>
Add `edit_command` function to confirm.rs:

```rust
use std::io::{self, BufRead, Write};

/// Prompt user to edit a command.
///
/// Displays the current command and asks for a new version.
/// If user enters empty line, returns the original command.
///
/// # Arguments
/// * `original` - The original command to edit
///
/// # Returns
/// The edited command (or original if unchanged)
pub fn edit_command(original: &str) -> io::Result<String> {
    println!();
    println!("Current command: {}", original);
    print!("Enter new command (or press Enter to keep): ");
    io::stdout().flush()?;

    let mut input = String::new();
    io::stdin().lock().read_line(&mut input)?;
    let edited = input.trim();

    if edited.is_empty() {
        Ok(original.to_string())
    } else {
        Ok(edited.to_string())
    }
}
```

Update the existing `confirm_command` function to remove `#[allow(dead_code)]` since it will now be used.

Add tests:
- edit_command with empty input returns original (needs stdin mock, skip if complex)
- Integration test comments for future
  </action>
  <verify>cargo check -p cherry2k</verify>
  <done>Edit command flow implemented</done>
</task>

<task type="auto">
  <name>Task 3: Export confirm functions</name>
  <files>crates/cli/src/lib.rs</files>
  <action>
Ensure confirm.rs exports are accessible. The module should already be public, but verify:

In lib.rs, confirm should be:
```rust
pub mod confirm;
```

The functions `confirm`, `confirm_command`, and `edit_command` should be public and accessible as `cherry2k::confirm::*`.

Run clippy to ensure no dead_code warnings for the confirm functions that were previously unused.
  </action>
  <verify>cargo clippy -p cherry2k -- -D warnings</verify>
  <done>Confirm module exports all functions, no dead_code warnings</done>
</task>

</tasks>

<verification>
- `cargo check -p cherry2k` succeeds
- `cargo clippy -p cherry2k -- -D warnings` passes with no dead_code warnings
- Manual test: display_suggested_command renders with syntax highlighting
</verification>

<success_criteria>
- Commands display with bash syntax highlighting via termimad
- Context text appears before command block when present
- edit_command prompts for new command
- Empty edit input preserves original command
- No dead_code warnings for confirm functions
</success_criteria>

<output>
After completion, create `.planning/phases/06-command-execution-flow/06-03-SUMMARY.md`
</output>
