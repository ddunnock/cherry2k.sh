---
phase: 06-command-execution-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/cli/Cargo.toml
  - crates/cli/src/execute/mod.rs
  - crates/cli/src/execute/runner.rs
  - crates/cli/src/execute/output.rs
  - crates/cli/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Commands execute via sh -c with piped stdout/stderr"
    - "Command output streams in real-time (line-buffered)"
    - "Stderr displays in red/distinct color"
    - "Exit code shows on completion (success: green checkmark, failure: red X)"
    - "Ctrl+C propagates to child process"
  artifacts:
    - path: "crates/cli/src/execute/runner.rs"
      provides: "Async command execution with streaming"
      exports: ["execute_command", "CommandResult"]
    - path: "crates/cli/src/execute/output.rs"
      provides: "Exit status display formatting"
      exports: ["display_exit_status"]
    - path: "crates/cli/src/execute/mod.rs"
      provides: "Module exports"
  key_links:
    - from: "runner.rs"
      to: "tokio::process::Command"
      via: "sh -c execution"
      pattern: "Command::new.*sh"
    - from: "output.rs"
      to: "ExitStatus"
      via: "status code formatting"
      pattern: "ExitStatus"
---

<objective>
Create shell command execution module with real-time streaming output and signal handling.

Purpose: Execute user-approved commands asynchronously with proper stdout/stderr streaming, ANSI coloring for errors, exit code display, and Ctrl+C signal forwarding to child processes.

Output: Execution module in crates/cli/src/execute/ with runner and output formatting.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-command-execution-flow/06-CONTEXT.md
@.planning/phases/06-command-execution-flow/06-RESEARCH.md
@crates/cli/src/output/stream_writer.rs
@crates/cli/src/signal.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nix dependency and create output formatter</name>
  <files>Cargo.toml, crates/cli/Cargo.toml, crates/cli/src/execute/output.rs</files>
  <action>
Add nix dependency to workspace Cargo.toml:
```toml
nix = { version = "0.30", features = ["signal"] }
```

Add nix to crates/cli/Cargo.toml dependencies:
```toml
nix.workspace = true
```

Create output.rs with exit status display:

```rust
use std::process::ExitStatus;
use colored::Colorize;

/// Display the exit status of a completed command.
///
/// Shows:
/// - Green checkmark with "exit 0" on success
/// - Red X with exit code on failure
/// - Yellow warning for signal termination
pub fn display_exit_status(status: ExitStatus) {
    if status.success() {
        println!("{}", "✓ Command completed (exit 0)".green());
    } else {
        match status.code() {
            Some(code) => {
                println!("{}", format!("✗ Command failed (exit {})", code).red());
            }
            None => {
                // Process terminated by signal
                #[cfg(unix)]
                {
                    use std::os::unix::process::ExitStatusExt;
                    if let Some(sig) = status.signal() {
                        println!("{}", format!("⚠ Terminated by signal {}", sig).yellow());
                    } else {
                        println!("{}", "⚠ Terminated abnormally".yellow());
                    }
                }
                #[cfg(not(unix))]
                {
                    println!("{}", "⚠ Terminated abnormally".yellow());
                }
            }
        }
    }
}
```

Add tests for exit status display (cannot easily test output, but test that function runs without panic).
  </action>
  <verify>cargo check -p cherry2k</verify>
  <done>Exit status formatter compiles with nix dependency</done>
</task>

<task type="auto">
  <name>Task 2: Implement command runner with streaming</name>
  <files>crates/cli/src/execute/runner.rs</files>
  <action>
Create runner.rs with async command execution:

```rust
use std::io;
use std::process::{ExitStatus, Stdio};
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::process::Command;
use colored::Colorize;
use tokio_util::sync::CancellationToken;

/// Result of command execution
pub struct CommandResult {
    pub status: ExitStatus,
    pub was_cancelled: bool,
}

/// Execute a shell command with real-time streaming output.
///
/// - Runs command via `sh -c` for shell interpretation
/// - Streams stdout line-by-line to terminal
/// - Streams stderr line-by-line in red
/// - Forwards Ctrl+C to child process via SIGINT
/// - Uses `kill_on_drop(true)` for cleanup safety
///
/// # Arguments
/// * `cmd` - The command string to execute
/// * `cancel_token` - Optional cancellation token for Ctrl+C handling
///
/// # Returns
/// CommandResult with exit status and cancellation flag
pub async fn execute_command(
    cmd: &str,
    cancel_token: Option<CancellationToken>,
) -> io::Result<CommandResult> {
    let mut child = Command::new("sh")
        .args(["-c", cmd])
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .kill_on_drop(true)
        .spawn()?;

    let child_id = child.id();
    let stdout = child.stdout.take().expect("stdout piped");
    let stderr = child.stderr.take().expect("stderr piped");

    // Spawn task to read stderr (in red)
    let stderr_handle = tokio::spawn(async move {
        let mut reader = BufReader::new(stderr).lines();
        while let Ok(Some(line)) = reader.next_line().await {
            eprintln!("{}", line.red());
        }
    });

    // Read stdout, handling cancellation
    let mut stdout_reader = BufReader::new(stdout).lines();
    let mut was_cancelled = false;

    loop {
        tokio::select! {
            biased;  // Check cancellation first

            _ = async {
                if let Some(ref token) = cancel_token {
                    token.cancelled().await
                } else {
                    // Never completes if no token
                    std::future::pending::<()>().await
                }
            } => {
                // Ctrl+C received - send SIGINT to child
                if let Some(id) = child_id {
                    #[cfg(unix)]
                    {
                        use nix::sys::signal::{kill, Signal};
                        use nix::unistd::Pid;
                        // Send SIGINT to process group (negative pid)
                        let _ = kill(Pid::from_raw(-(id as i32)), Signal::SIGINT);
                    }
                }
                was_cancelled = true;
                break;
            }

            line = stdout_reader.next_line() => {
                match line {
                    Ok(Some(line)) => println!("{}", line),
                    Ok(None) => break,  // EOF
                    Err(e) => {
                        eprintln!("{}", format!("Error reading output: {}", e).red());
                        break;
                    }
                }
            }
        }
    }

    // Wait for stderr task
    let _ = stderr_handle.await;

    // Wait for child to exit
    let status = child.wait().await?;

    Ok(CommandResult {
        status,
        was_cancelled,
    })
}
```

Add integration-style test that runs `echo hello` and verifies exit 0.
  </action>
  <verify>cargo test -p cherry2k execute::runner</verify>
  <done>Command runner executes commands with streaming output</done>
</task>

<task type="auto">
  <name>Task 3: Wire execute module into CLI</name>
  <files>crates/cli/src/execute/mod.rs, crates/cli/src/lib.rs</files>
  <action>
Create mod.rs that exports:
```rust
mod runner;
mod output;

pub use runner::{execute_command, CommandResult};
pub use output::display_exit_status;
```

Update crates/cli/src/lib.rs to add:
```rust
pub mod execute;
```

Ensure the module is accessible as `cherry2k::execute::*`.
  </action>
  <verify>cargo check -p cherry2k && cargo test -p cherry2k execute</verify>
  <done>Execute module is exported and all tests pass</done>
</task>

</tasks>

<verification>
- `cargo check -p cherry2k` succeeds
- `cargo test -p cherry2k execute` runs tests for the new module
- `cargo clippy -p cherry2k -- -D warnings` passes
- Manual test: The runner can execute `echo "test"` and stream output
</verification>

<success_criteria>
- Commands execute via sh -c with piped IO
- Stdout streams line-by-line to terminal
- Stderr streams in red color
- Exit status displays with appropriate icon/color
- Ctrl+C sends SIGINT to child process group
- kill_on_drop ensures cleanup on panic/early return
</success_criteria>

<output>
After completion, create `.planning/phases/06-command-execution-flow/06-02-SUMMARY.md`
</output>
