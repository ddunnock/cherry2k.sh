---
phase: 04-zsh-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - zsh/widgets/ai-mode.zsh
  - crates/cli/src/main.rs
  - crates/cli/src/commands/chat.rs
autonomous: true

must_haves:
  truths:
    - "User presses Enter in AI mode and sees streaming response"
    - "AI queries do not appear in shell history"
    - "User can Ctrl+C to cancel streaming and return to prompt"
    - "Response displays in retro 8-bit style (green text)"
  artifacts:
    - path: "zsh/widgets/ai-mode.zsh"
      provides: "Accept-line widget, context collection, AI invocation"
      contains: "_cherry2k_ai_mode_accept"
    - path: "crates/cli/src/commands/chat.rs"
      provides: "Updated chat command with context-file flag and retro output"
      contains: "context-file"
  key_links:
    - from: "zsh/widgets/ai-mode.zsh"
      to: "cherry2k chat"
      via: "subprocess invocation"
      pattern: "cherry2k chat.*--context-file"
    - from: "_cherry2k_ai_mode_accept"
      to: "_cherry2k_collect_context"
      via: "function call"
      pattern: "_cherry2k_collect_context"
---

<objective>
Implement the shell functions for AI invocation, context collection, and streaming response display.

Purpose: When user presses Enter in AI mode, their query goes to the Rust backend with shell context. The response streams inline with retro styling. History is kept clean (no AI queries pollute it).

Output: Complete AI query flow from Enter press to response completion.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-zsh-integration/04-CONTEXT.md
@.planning/phases/04-zsh-integration/04-RESEARCH.md
@.planning/phases/04-zsh-integration/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context collection and AI invocation to zsh widget</name>
  <files>zsh/widgets/ai-mode.zsh</files>
  <action>
Extend ai-mode.zsh with Enter handling, context collection, and AI invocation.

**Add `_cherry2k_collect_context` function:**
- Set `CHERRY2K_CONTEXT_DEPTH` default to 10 if not set
- Create temp file with mktemp
- Build JSON structure with:
  - "pwd": Current directory ($PWD)
  - "shell": $SHELL
  - "zsh_version": $ZSH_VERSION
  - "history": Array of last N commands using `fc -rli -${context_depth}`
  - "env": Filtered env (USER, HOME, TERM only - no secrets)
- Use jq for JSON escaping of command strings (dependency note: jq must be installed)
- Echo path to temp file (caller cleans up)

**Add `_cherry2k_ai_mode_accept` widget:**
- Check `_CHERRY2K_AI_MODE` - if 0, call original accept-line
- Extract query: `local query="${BUFFER#\* }"`
- If query empty, exit AI mode and accept empty line
- **History prevention:** Set BUFFER="" before accept-line (history sees empty)
- Save original buffer for processing
- Call `zle .accept-line` with empty buffer
- Print newline to move query up visually
- Collect context to temp file
- Setup SIGINT trap for cleanup during streaming
- Invoke: `cherry2k chat --context-file="$context_file" "$query"`
- Capture exit code
- Cleanup: remove context file, restore trap
- Exit AI mode
- Reset prompt with `zle .reset-prompt`
- Return exit code

**Register widget:**
- `zle -N _cherry2k_ai_mode_accept`
- Bind in AI mode: handled in Plan 03 (keybindings)
- For now, rebind Enter in `_cherry2k_enter_ai_mode`: `bindkey '^M' _cherry2k_ai_mode_accept`
- Restore original Enter in `_cherry2k_exit_ai_mode`: `bindkey '^M' accept-line`

Reference patterns from 04-RESEARCH.md Pattern 4 (context), Pattern 5 (streaming), Pattern 6 (signals).
  </action>
  <verify>
```bash
# In zsh with plugin sourced
source zsh/cherry2k.plugin.zsh
# Type "* what is 2+2"
# Press Enter
# Should see response stream (if cherry2k binary exists and OpenAI configured)
# Check: history | tail -1 should NOT show the AI query
```
  </verify>
  <done>
- Enter in AI mode invokes cherry2k chat
- Context JSON passed via temp file
- AI queries excluded from history
- Ctrl+C cleans up properly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --context-file flag and retro styling to chat command</name>
  <files>crates/cli/src/main.rs, crates/cli/src/commands/chat.rs</files>
  <action>
Extend chat command to accept shell context from zsh integration.

**crates/cli/src/main.rs:**
- Add `context_file: Option<PathBuf>` to Chat command struct
- Add clap attribute: `#[arg(long, help = "Path to JSON file with shell context")]`
- Pass to `commands::chat::run`

**crates/cli/src/commands/chat.rs:**
- Update `run` signature to take `context_file: Option<&Path>`
- If context_file provided:
  - Read JSON file using `std::fs::read_to_string`
  - Parse with serde_json into a `ShellContext` struct
  - Log context at debug level
  - (Phase 6 will use context for intent detection; for now just capture it)
- Define `ShellContext` struct (private, just for parsing):
  - `pwd: String`
  - `shell: String`
  - `zsh_version: Option<String>`
  - `history: Vec<HistoryEntry>`
  - `env: std::collections::HashMap<String, String>`
- Define `HistoryEntry` struct:
  - `timestamp: Option<String>`
  - `command: String`
- Import `apply_retro_skin` and modify markdown output:
  - In `StreamWriter::new()`, apply retro skin to the MadSkin
  - Or if StreamWriter doesn't use MadSkin directly, add method to configure skin
  - The goal: responses appear in bright green text (8-bit retro style)

**Note on retro styling integration:**
- Check how StreamWriter and markdown.rs work
- If they already use MadSkin, apply retro colors there
- If not, at minimum log that context was received (retro styling can be refined)
  </action>
  <verify>
```bash
# Create test context file
echo '{"pwd":"/tmp","shell":"/bin/zsh","history":[],"env":{}}' > /tmp/test-context.json
cargo run -p cherry2k-cli -- chat --context-file=/tmp/test-context.json "hello"
# Should work and log context at debug level
RUST_LOG=debug cargo run -p cherry2k-cli -- chat --context-file=/tmp/test-context.json "hello" 2>&1 | grep -i context
```
  </verify>
  <done>
- Chat command accepts --context-file flag
- Shell context parsed and logged
- Retro color scheme applied to output (or documented for future refinement)
  </done>
</task>

</tasks>

<verification>
1. Full flow works: `* hello` -> Enter -> response streams
2. `history | grep hello` returns nothing (history clean)
3. Ctrl+C during streaming cleans up properly
4. `--context-file` flag works with cherry2k chat
5. Debug logs show context when RUST_LOG=debug
</verification>

<success_criteria>
- User types `* what is my IP`, presses Enter, sees streamed response
- AI queries never appear in shell history
- Context file passed from zsh to Rust backend
- Streaming can be cancelled with Ctrl+C
</success_criteria>

<output>
After completion, create `.planning/phases/04-zsh-integration/04-02-SUMMARY.md`
</output>
