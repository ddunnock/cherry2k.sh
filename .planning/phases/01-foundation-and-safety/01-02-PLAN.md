---
phase: 01-foundation-and-safety
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/core/Cargo.toml
  - crates/core/src/lib.rs
  - crates/core/src/config.rs
  - crates/core/src/config/mod.rs
  - crates/core/src/config/types.rs
  - crates/core/src/config/loader.rs
autonomous: true

must_haves:
  truths:
    - "Configuration loads from ~/.config/cherry2k/config.toml when present"
    - "Environment variables override config file values"
    - "Missing config file returns sensible defaults (not error)"
    - "Invalid config returns ConfigError with clear message"
  artifacts:
    - path: "crates/core/src/config/types.rs"
      provides: "Config struct definitions with serde derive"
      contains: "#[derive(Debug, Deserialize)]"
    - path: "crates/core/src/config/loader.rs"
      provides: "Config loading logic with env override"
      contains: "fn load"
  key_links:
    - from: "crates/core/src/config/loader.rs"
      to: "crates/core/src/error.rs"
      via: "returns ConfigError"
      pattern: "ConfigError"
    - from: "crates/core/src/config/types.rs"
      to: "env vars"
      via: "override logic"
      pattern: "CHERRY2K_|OPENAI_|ANTHROPIC_|OLLAMA_"
---

<objective>
Implement configuration loading with TOML file support and environment variable overrides.

Purpose: Configuration is required before CLI commands can function. The loader must handle missing files gracefully (return defaults) while catching actual errors (malformed TOML). Environment variables like OPENAI_API_KEY must override file values.

Output: Working config module that CLI can import and use.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/phases/01-foundation-and-safety/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config dependencies and create module structure</name>
  <files>
    crates/core/Cargo.toml
    crates/core/src/lib.rs
    crates/core/src/config/mod.rs
  </files>
  <action>
Update crates/core/Cargo.toml to add config dependencies:
- toml = "0.8" (for parsing config files)
- directories = "5" (for XDG paths like ~/.config/cherry2k)

Add to workspace Cargo.toml [workspace.dependencies]:
- toml = "0.8"
- directories = "5"

Then use workspace = true in core's Cargo.toml.

Update crates/core/src/lib.rs:
- pub mod config;
- pub mod error;

Create crates/core/src/config/mod.rs:
- mod types;
- mod loader;
- pub use types::*;
- pub use loader::load_config;
  </action>
  <verify>
Run `cargo check -p cherry2k-core` - should compile
  </verify>
  <done>Config module structure exists with dependencies available</done>
</task>

<task type="auto">
  <name>Task 2: Define configuration types</name>
  <files>crates/core/src/config/types.rs</files>
  <action>
Create config type definitions:

```rust
use serde::Deserialize;
use std::path::PathBuf;

/// Root configuration structure
#[derive(Debug, Clone, Deserialize, Default)]
#[serde(default)]
pub struct Config {
    /// General settings
    pub general: GeneralConfig,
    /// OpenAI provider settings
    pub openai: Option<OpenAiConfig>,
    /// Anthropic provider settings
    pub anthropic: Option<AnthropicConfig>,
    /// Ollama provider settings
    pub ollama: Option<OllamaConfig>,
    /// Safety settings
    pub safety: SafetyConfig,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct GeneralConfig {
    /// Default provider to use (openai, anthropic, ollama)
    pub default_provider: String,
    /// Log level (trace, debug, info, warn, error)
    pub log_level: String,
}

impl Default for GeneralConfig {
    fn default() -> Self {
        Self {
            default_provider: "openai".to_string(),
            log_level: "info".to_string(),
        }
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct OpenAiConfig {
    /// API key (prefer env var OPENAI_API_KEY)
    pub api_key: Option<String>,
    /// Base URL for API (default: https://api.openai.com/v1)
    /// Allows using OpenAI-compatible APIs like z.ai
    #[serde(default = "default_openai_base_url")]
    pub base_url: String,
    /// Model to use (default: gpt-4o)
    #[serde(default = "default_openai_model")]
    pub model: String,
}

fn default_openai_base_url() -> String {
    "https://api.openai.com/v1".to_string()
}

fn default_openai_model() -> String {
    "gpt-4o".to_string()
}

#[derive(Debug, Clone, Deserialize)]
pub struct AnthropicConfig {
    /// API key (prefer env var ANTHROPIC_API_KEY)
    pub api_key: Option<String>,
    /// Model to use (default: claude-sonnet-4-20250514)
    #[serde(default = "default_anthropic_model")]
    pub model: String,
}

fn default_anthropic_model() -> String {
    "claude-sonnet-4-20250514".to_string()
}

#[derive(Debug, Clone, Deserialize)]
pub struct OllamaConfig {
    /// Ollama host URL (default: http://localhost:11434)
    #[serde(default = "default_ollama_host")]
    pub host: String,
    /// Model to use (default: llama3.2)
    #[serde(default = "default_ollama_model")]
    pub model: String,
}

fn default_ollama_host() -> String {
    "http://localhost:11434".to_string()
}

fn default_ollama_model() -> String {
    "llama3.2".to_string()
}

#[derive(Debug, Clone, Deserialize)]
#[serde(default)]
pub struct SafetyConfig {
    /// Require confirmation before executing commands (default: true)
    pub confirm_commands: bool,
    /// Require confirmation before file writes (default: true)
    pub confirm_file_writes: bool,
    /// List of blocked command patterns
    pub blocked_patterns: Vec<String>,
}

impl Default for SafetyConfig {
    fn default() -> Self {
        Self {
            confirm_commands: true,
            confirm_file_writes: true,
            blocked_patterns: vec![
                "rm -rf /".to_string(),
                "rm -rf ~".to_string(),
                "> /dev/sda".to_string(),
                "mkfs".to_string(),
                ":(){:|:&};:".to_string(), // fork bomb
            ],
        }
    }
}
```

All config sections use serde(default) so missing sections in TOML don't cause errors.
  </action>
  <verify>
Run `cargo check -p cherry2k-core`
Run `cargo doc -p cherry2k-core --no-deps` - config types should be documented
  </verify>
  <done>Config types defined with sensible defaults for all providers</done>
</task>

<task type="auto">
  <name>Task 3: Implement config loader with env var overrides</name>
  <files>crates/core/src/config/loader.rs</files>
  <action>
Implement the config loading logic:

```rust
use crate::config::types::*;
use crate::error::ConfigError;
use directories::ProjectDirs;
use std::env;
use std::fs;
use std::path::PathBuf;

/// Load configuration from file and environment variables.
///
/// Priority (highest to lowest):
/// 1. Environment variables (OPENAI_API_KEY, ANTHROPIC_API_KEY, etc.)
/// 2. Config file (~/.config/cherry2k/config.toml or CHERRY2K_CONFIG_PATH)
/// 3. Compiled defaults
///
/// # Errors
/// Returns ConfigError if config file exists but is malformed.
/// Missing config file is NOT an error - defaults are used.
pub fn load_config() -> Result<Config, ConfigError> {
    // Find config file path
    let config_path = get_config_path();

    // Load from file if exists
    let mut config = if config_path.exists() {
        let content = fs::read_to_string(&config_path)
            .map_err(ConfigError::ReadError)?;
        toml::from_str(&content)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?
    } else {
        Config::default()
    };

    // Apply environment variable overrides
    apply_env_overrides(&mut config);

    Ok(config)
}

/// Get the config file path.
/// Uses CHERRY2K_CONFIG_PATH if set, otherwise ~/.config/cherry2k/config.toml
pub fn get_config_path() -> PathBuf {
    if let Ok(path) = env::var("CHERRY2K_CONFIG_PATH") {
        return PathBuf::from(path);
    }

    if let Some(proj_dirs) = ProjectDirs::from("com", "cherry2k", "cherry2k") {
        proj_dirs.config_dir().join("config.toml")
    } else {
        // Fallback if home directory detection fails
        PathBuf::from("~/.config/cherry2k/config.toml")
    }
}

/// Apply environment variable overrides to config.
fn apply_env_overrides(config: &mut Config) {
    // Log level override
    if let Ok(level) = env::var("CHERRY2K_LOG_LEVEL") {
        config.general.log_level = level;
    }

    // Default provider override
    if let Ok(provider) = env::var("CHERRY2K_PROVIDER") {
        config.general.default_provider = provider;
    }

    // OpenAI overrides
    if let Ok(key) = env::var("OPENAI_API_KEY") {
        let openai = config.openai.get_or_insert_with(|| OpenAiConfig {
            api_key: None,
            base_url: "https://api.openai.com/v1".to_string(),
            model: "gpt-4o".to_string(),
        });
        openai.api_key = Some(key);
    }
    if let Ok(base_url) = env::var("OPENAI_BASE_URL") {
        if let Some(ref mut openai) = config.openai {
            openai.base_url = base_url;
        }
    }
    if let Ok(model) = env::var("OPENAI_MODEL") {
        if let Some(ref mut openai) = config.openai {
            openai.model = model;
        }
    }

    // Anthropic overrides
    if let Ok(key) = env::var("ANTHROPIC_API_KEY") {
        let anthropic = config.anthropic.get_or_insert_with(|| AnthropicConfig {
            api_key: None,
            model: "claude-sonnet-4-20250514".to_string(),
        });
        anthropic.api_key = Some(key);
    }
    if let Ok(model) = env::var("ANTHROPIC_MODEL") {
        if let Some(ref mut anthropic) = config.anthropic {
            anthropic.model = model;
        }
    }

    // Ollama overrides
    if let Ok(host) = env::var("OLLAMA_HOST") {
        let ollama = config.ollama.get_or_insert_with(|| OllamaConfig {
            host: "http://localhost:11434".to_string(),
            model: "llama3.2".to_string(),
        });
        ollama.host = host;
    }
    if let Ok(model) = env::var("OLLAMA_MODEL") {
        if let Some(ref mut ollama) = config.ollama {
            ollama.model = model;
        }
    }

    // Safety overrides (for testing/power users)
    if let Ok(val) = env::var("CHERRY2K_CONFIRM_COMMANDS") {
        config.safety.confirm_commands = val.parse().unwrap_or(true);
    }
    if let Ok(val) = env::var("CHERRY2K_CONFIRM_FILE_WRITES") {
        config.safety.confirm_file_writes = val.parse().unwrap_or(true);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_default_config_when_no_file() {
        // Ensure no config file exists at test path
        env::set_var("CHERRY2K_CONFIG_PATH", "/nonexistent/path/config.toml");
        let config = load_config().unwrap();
        assert_eq!(config.general.default_provider, "openai");
        assert!(config.safety.confirm_commands);
        env::remove_var("CHERRY2K_CONFIG_PATH");
    }

    #[test]
    fn test_env_override() {
        env::set_var("CHERRY2K_CONFIG_PATH", "/nonexistent/path/config.toml");
        env::set_var("OPENAI_API_KEY", "test-key-123");
        let config = load_config().unwrap();
        assert_eq!(config.openai.as_ref().unwrap().api_key, Some("test-key-123".to_string()));
        env::remove_var("CHERRY2K_CONFIG_PATH");
        env::remove_var("OPENAI_API_KEY");
    }

    #[test]
    fn test_config_file_parsing() {
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, r#"
[general]
default_provider = "anthropic"
log_level = "debug"

[safety]
confirm_commands = false
"#).unwrap();

        env::set_var("CHERRY2K_CONFIG_PATH", file.path().to_str().unwrap());
        let config = load_config().unwrap();
        assert_eq!(config.general.default_provider, "anthropic");
        assert_eq!(config.general.log_level, "debug");
        assert!(!config.safety.confirm_commands);
        env::remove_var("CHERRY2K_CONFIG_PATH");
    }

    #[test]
    fn test_invalid_toml_returns_error() {
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "this is not valid toml {{{{").unwrap();

        env::set_var("CHERRY2K_CONFIG_PATH", file.path().to_str().unwrap());
        let result = load_config();
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ConfigError::ParseError(_)));
        env::remove_var("CHERRY2K_CONFIG_PATH");
    }
}
```

Add tempfile to dev-dependencies in crates/core/Cargo.toml:
```toml
[dev-dependencies]
tempfile = "3"
```

Add to workspace Cargo.toml [workspace.dependencies]:
```toml
tempfile = "3"
```
  </action>
  <verify>
Run `cargo test -p cherry2k-core` - all tests pass
Run `cargo clippy -p cherry2k-core -- -D warnings` - no warnings
  </verify>
  <done>Config loading works with file + env var override; tests verify behavior</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check --workspace` passes
2. `cargo test -p cherry2k-core` passes (config tests)
3. `cargo clippy --workspace -- -D warnings` passes
4. Config module exports Config, load_config, and all sub-types
5. Missing config file returns defaults (not error)
6. Malformed config file returns ConfigError::ParseError
7. Environment variables override file values
</verification>

<success_criteria>
- `cargo test -p cherry2k-core` passes with all config tests
- Config loads from file when present
- Environment variables override config file
- Missing config file returns defaults
- Invalid config returns clear ConfigError
- API keys can be loaded from env vars (OPENAI_API_KEY, ANTHROPIC_API_KEY)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-safety/01-02-SUMMARY.md`
</output>
