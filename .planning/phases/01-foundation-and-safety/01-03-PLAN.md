---
phase: 01-foundation-and-safety
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
  - crates/cli/src/commands/mod.rs
  - crates/cli/src/commands/chat.rs
  - crates/cli/src/confirm.rs
autonomous: true

must_haves:
  truths:
    - "User can run cherry2k --help and see available commands"
    - "User can run cherry2k --version and see version info"
    - "cherry2k chat command exists (shows placeholder message)"
    - "Confirmation prompt can ask y/n and return user choice"
  artifacts:
    - path: "crates/cli/src/main.rs"
      provides: "CLI entry point with clap"
      contains: "#[derive(Parser)]"
    - path: "crates/cli/src/commands/chat.rs"
      provides: "Chat command handler (placeholder)"
      contains: "pub async fn run"
    - path: "crates/cli/src/confirm.rs"
      provides: "Confirmation prompt utility"
      contains: "pub fn confirm"
  key_links:
    - from: "crates/cli/src/main.rs"
      to: "crates/core/src/config/loader.rs"
      via: "config loading on startup"
      pattern: "load_config"
    - from: "crates/cli/src/commands/chat.rs"
      to: "crates/cli/src/confirm.rs"
      via: "confirmation before action"
      pattern: "confirm::"
---

<objective>
Create CLI skeleton with clap, --help, --version, chat subcommand placeholder, and confirmation prompt utility.

Purpose: The CLI is the user-facing interface. Phase 1 establishes the command structure and the safety-critical confirmation flow that will be used before executing AI-suggested commands.

Output: Working CLI that responds to --help, --version, and has a chat subcommand stub.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/phases/01-foundation-and-safety/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-safety/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add clap and set up CLI structure</name>
  <files>
    crates/cli/Cargo.toml
    crates/cli/src/main.rs
    crates/cli/src/commands/mod.rs
    crates/cli/src/commands/chat.rs
  </files>
  <action>
Update workspace Cargo.toml to add clap:
```toml
clap = { version = "4.5", features = ["derive"] }
```

Update crates/cli/Cargo.toml:
```toml
[package]
name = "cherry2k"
version.workspace = true
edition.workspace = true

[[bin]]
name = "cherry2k"
path = "src/main.rs"

[dependencies]
cherry2k-core = { path = "../core" }
cherry2k-storage = { path = "../storage" }
tokio.workspace = true
anyhow.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true
clap.workspace = true

[lints]
workspace = true
```

Create crates/cli/src/main.rs:
```rust
use anyhow::Result;
use clap::{Parser, Subcommand};
use tracing_subscriber::EnvFilter;

mod commands;
mod confirm;

/// Cherry2K - Zsh Terminal AI Assistant
#[derive(Parser)]
#[command(name = "cherry2k")]
#[command(version, about, long_about = None)]
struct Cli {
    /// Set log level (trace, debug, info, warn, error)
    #[arg(short, long, default_value = "info")]
    log_level: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Chat with AI (one-shot query)
    Chat {
        /// The message to send to the AI
        message: String,
    },
    /// Show current configuration
    Config,
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    // Initialize logging
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new(&cli.log_level));
    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .init();

    // Load configuration
    let config = cherry2k_core::config::load_config()?;
    tracing::debug!("Configuration loaded: {:?}", config.general);

    // Dispatch to command handlers
    match cli.command {
        Commands::Chat { message } => {
            commands::chat::run(&config, &message).await?;
        }
        Commands::Config => {
            commands::config::run(&config)?;
        }
    }

    Ok(())
}
```

Create crates/cli/src/commands/mod.rs:
```rust
pub mod chat;
pub mod config;
```

Create crates/cli/src/commands/chat.rs:
```rust
use anyhow::Result;
use cherry2k_core::config::Config;

/// Run the chat command.
///
/// Currently a placeholder that shows the message would be sent.
/// Phase 2 will add actual provider integration.
pub async fn run(config: &Config, message: &str) -> Result<()> {
    println!("Chat command received.");
    println!("Provider: {}", config.general.default_provider);
    println!("Message: {}", message);
    println!();
    println!("[Phase 2 will add AI provider integration]");

    // Demonstrate the confirmation flow would happen here
    if config.safety.confirm_commands {
        println!();
        println!("(Safety: Command confirmation is ENABLED)");
    }

    Ok(())
}
```

Create crates/cli/src/commands/config.rs:
```rust
use anyhow::Result;
use cherry2k_core::config::Config;

/// Show current configuration.
pub fn run(config: &Config) -> Result<()> {
    println!("Cherry2K Configuration");
    println!("======================");
    println!();

    println!("[General]");
    println!("  Default provider: {}", config.general.default_provider);
    println!("  Log level: {}", config.general.log_level);
    println!();

    println!("[Safety]");
    println!("  Confirm commands: {}", config.safety.confirm_commands);
    println!("  Confirm file writes: {}", config.safety.confirm_file_writes);
    println!("  Blocked patterns: {}", config.safety.blocked_patterns.len());
    println!();

    if let Some(ref openai) = config.openai {
        println!("[OpenAI]");
        println!("  Base URL: {}", openai.base_url);
        println!("  Model: {}", openai.model);
        println!("  API key: {}", if openai.api_key.is_some() { "configured" } else { "not set" });
        println!();
    }

    if let Some(ref anthropic) = config.anthropic {
        println!("[Anthropic]");
        println!("  Model: {}", anthropic.model);
        println!("  API key: {}", if anthropic.api_key.is_some() { "configured" } else { "not set" });
        println!();
    }

    if let Some(ref ollama) = config.ollama {
        println!("[Ollama]");
        println!("  Host: {}", ollama.host);
        println!("  Model: {}", ollama.model);
        println!();
    }

    Ok(())
}
```
  </action>
  <verify>
Run `cargo build -p cherry2k`
Run `./target/debug/cherry2k --help` - should show usage
Run `./target/debug/cherry2k --version` - should show version
Run `./target/debug/cherry2k chat "test"` - should show placeholder output
Run `./target/debug/cherry2k config` - should show configuration
  </verify>
  <done>CLI responds to --help, --version, has chat and config subcommands</done>
</task>

<task type="auto">
  <name>Task 2: Create confirmation prompt utility</name>
  <files>crates/cli/src/confirm.rs</files>
  <action>
Create the confirmation prompt utility that will be used for command execution safety:

```rust
use std::io::{self, BufRead, Write};

/// Result of a confirmation prompt
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfirmResult {
    /// User confirmed (yes)
    Yes,
    /// User denied (no)
    No,
    /// User wants to edit before confirming
    Edit,
}

/// Prompt the user for confirmation.
///
/// Displays the prompt and waits for y/n/e input.
/// - y/Y/yes -> ConfirmResult::Yes
/// - n/N/no -> ConfirmResult::No
/// - e/E/edit -> ConfirmResult::Edit
///
/// # Arguments
/// * `prompt` - The question to ask
/// * `allow_edit` - Whether to show the (e)dit option
///
/// # Example
/// ```no_run
/// use cherry2k::confirm::{confirm, ConfirmResult};
///
/// let result = confirm("Run this command?", false)?;
/// match result {
///     ConfirmResult::Yes => println!("Proceeding..."),
///     ConfirmResult::No => println!("Cancelled."),
///     ConfirmResult::Edit => println!("Editing..."),
/// }
/// ```
pub fn confirm(prompt: &str, allow_edit: bool) -> io::Result<ConfirmResult> {
    let options = if allow_edit {
        "[y/n/e]"
    } else {
        "[y/n]"
    };

    loop {
        print!("{} {} ", prompt, options);
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().lock().read_line(&mut input)?;
        let input = input.trim().to_lowercase();

        match input.as_str() {
            "y" | "yes" => return Ok(ConfirmResult::Yes),
            "n" | "no" => return Ok(ConfirmResult::No),
            "e" | "edit" if allow_edit => return Ok(ConfirmResult::Edit),
            "" => {
                // Empty input defaults to No for safety
                return Ok(ConfirmResult::No);
            }
            _ => {
                if allow_edit {
                    println!("Please enter 'y' for yes, 'n' for no, or 'e' to edit.");
                } else {
                    println!("Please enter 'y' for yes or 'n' for no.");
                }
            }
        }
    }
}

/// Confirm a potentially dangerous command before execution.
///
/// Displays the command and asks for confirmation.
/// Returns true if user confirms, false otherwise.
pub fn confirm_command(command: &str) -> io::Result<ConfirmResult> {
    println!();
    println!("Suggested command:");
    println!("  {}", command);
    println!();
    confirm("Run this?", true)
}

/// Confirm a file operation before execution.
///
/// Displays the operation details and asks for confirmation.
pub fn confirm_file_operation(operation: &str, path: &str) -> io::Result<ConfirmResult> {
    println!();
    println!("{}: {}", operation, path);
    println!();
    confirm("Proceed?", false)
}

/// Check if a command matches any blocked patterns.
///
/// Returns Some(pattern) if blocked, None if allowed.
pub fn check_blocked_patterns<'a>(command: &str, patterns: &'a [String]) -> Option<&'a str> {
    for pattern in patterns {
        if command.contains(pattern) {
            return Some(pattern);
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blocked_patterns_match() {
        let patterns = vec![
            "rm -rf /".to_string(),
            "rm -rf ~".to_string(),
        ];
        assert!(check_blocked_patterns("rm -rf /", &patterns).is_some());
        assert!(check_blocked_patterns("sudo rm -rf /", &patterns).is_some());
        assert!(check_blocked_patterns("rm file.txt", &patterns).is_none());
    }

    #[test]
    fn test_blocked_patterns_empty() {
        let patterns: Vec<String> = vec![];
        assert!(check_blocked_patterns("rm -rf /", &patterns).is_none());
    }
}
```

This module provides:
1. `confirm()` - Generic y/n/e prompt
2. `confirm_command()` - Command-specific confirmation with edit option
3. `confirm_file_operation()` - File operation confirmation
4. `check_blocked_patterns()` - Safety check against dangerous patterns
  </action>
  <verify>
Run `cargo test -p cherry2k` - confirmation tests pass
Run `cargo clippy -p cherry2k -- -D warnings` - no warnings
  </verify>
  <done>Confirmation prompt utility exists with y/n/e support and blocked pattern checking</done>
</task>

<task type="auto">
  <name>Task 3: Integrate confirmation into chat command (demonstration)</name>
  <files>crates/cli/src/commands/chat.rs</files>
  <action>
Update chat.rs to demonstrate the confirmation flow that will be used in Phase 6:

```rust
use anyhow::Result;
use cherry2k_core::config::Config;
use crate::confirm::{self, ConfirmResult};

/// Run the chat command.
///
/// Currently a placeholder that demonstrates the confirmation flow.
/// Phase 2 will add actual provider integration.
pub async fn run(config: &Config, message: &str) -> Result<()> {
    println!("Cherry2K Chat");
    println!("=============");
    println!();
    println!("Provider: {}", config.general.default_provider);
    println!("Message: \"{}\"", message);
    println!();
    println!("[Phase 2 will add AI provider integration]");
    println!();

    // Demonstrate the confirmation flow (scaffolded for Phase 6)
    // This simulates what happens when AI suggests a command
    demonstrate_confirmation_flow(config)?;

    Ok(())
}

/// Demonstrate the confirmation flow that will be used for command execution.
fn demonstrate_confirmation_flow(config: &Config) -> Result<()> {
    println!("--- Confirmation Flow Demo ---");
    println!();

    // Example: AI would suggest this command
    let suggested_command = "echo 'Hello from Cherry2K!'";

    // Check against blocked patterns first
    if let Some(pattern) = confirm::check_blocked_patterns(suggested_command, &config.safety.blocked_patterns) {
        println!("BLOCKED: Command matches dangerous pattern: {}", pattern);
        return Ok(());
    }

    // If confirmation is enabled, ask user
    if config.safety.confirm_commands {
        match confirm::confirm_command(suggested_command)? {
            ConfirmResult::Yes => {
                println!();
                println!("User confirmed. [Would execute in Phase 6]");
            }
            ConfirmResult::No => {
                println!();
                println!("User cancelled.");
            }
            ConfirmResult::Edit => {
                println!();
                println!("User wants to edit. [Would open editor in Phase 6]");
            }
        }
    } else {
        println!("(Confirmation disabled - would auto-execute)");
        println!("Command: {}", suggested_command);
    }

    println!();
    println!("--- End Demo ---");

    Ok(())
}
```
  </action>
  <verify>
Run `cargo build -p cherry2k`
Run `./target/debug/cherry2k chat "test"` - should show confirmation demo
Test typing 'y', 'n', and 'e' at the prompt
  </verify>
  <done>Chat command demonstrates confirmation flow; y/n/e all work correctly</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build --workspace` succeeds
2. `./target/debug/cherry2k --help` shows usage with chat and config commands
3. `./target/debug/cherry2k --version` shows "cherry2k 0.1.0"
4. `./target/debug/cherry2k chat "hello"` shows placeholder + confirmation demo
5. `./target/debug/cherry2k config` shows configuration
6. Confirmation prompt accepts y/n/e input
7. Blocked pattern check works correctly
8. `cargo test --workspace` passes all tests
9. `cargo clippy --workspace -- -D warnings` passes
</verification>

<success_criteria>
- `cherry2k --help` displays help with available commands
- `cherry2k --version` displays version info
- `cherry2k chat "message"` runs without error (shows placeholder)
- `cherry2k config` shows current configuration
- Confirmation prompt utility functions correctly
- Blocked pattern detection works
- All clippy warnings resolved
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-safety/01-03-SUMMARY.md`
</output>
