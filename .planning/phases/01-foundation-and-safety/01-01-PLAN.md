---
phase: 01-foundation-and-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/core/Cargo.toml
  - crates/core/src/lib.rs
  - crates/core/src/error.rs
  - crates/storage/Cargo.toml
  - crates/storage/src/lib.rs
  - crates/cli/Cargo.toml
  - crates/cli/src/main.rs
  - rustfmt.toml
  - clippy.toml
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Cargo workspace builds without errors"
    - "All three crates compile (core, storage, cli)"
    - "Error types exist with clear variant names"
  artifacts:
    - path: "Cargo.toml"
      provides: "Workspace root configuration"
      contains: "[workspace]"
    - path: "crates/core/src/error.rs"
      provides: "Core error types using thiserror"
      contains: "#[derive(Debug, Error)]"
    - path: "crates/core/src/lib.rs"
      provides: "Core library exports"
      exports: ["error"]
  key_links:
    - from: "crates/cli/Cargo.toml"
      to: "crates/core"
      via: "workspace dependency"
      pattern: 'cherry2k-core.*path.*=.*"../core"'
---

<objective>
Create Rust workspace structure with three crates (core, storage, cli) and define foundational error types.

Purpose: Establish the monorepo structure and error handling patterns that all subsequent work depends on. Error types must be in place before config or CLI work begins.

Output: Compilable workspace with stub crates and fully-defined error types.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cargo workspace structure</name>
  <files>
    Cargo.toml
    crates/core/Cargo.toml
    crates/core/src/lib.rs
    crates/storage/Cargo.toml
    crates/storage/src/lib.rs
    crates/cli/Cargo.toml
    crates/cli/src/main.rs
    rustfmt.toml
    clippy.toml
    .gitignore
  </files>
  <action>
Create workspace root Cargo.toml:
- resolver = "2"
- members = ["crates/core", "crates/storage", "crates/cli"]
- workspace.package with version "0.1.0", edition "2021", authors, license "MIT"
- workspace.dependencies section with shared deps:
  - tokio = { version = "1.35", features = ["full"] }
  - serde = { version = "1.0", features = ["derive"] }
  - serde_json = "1.0"
  - thiserror = "2.0"
  - anyhow = "1.0"
  - tracing = "0.1"
  - tracing-subscriber = { version = "0.3", features = ["env-filter"] }
- workspace.lints.rust with unsafe_code = "forbid"

Create crates/core/Cargo.toml:
- name = "cherry2k-core"
- version.workspace = true, edition.workspace = true
- dependencies: thiserror.workspace = true, serde.workspace = true
- lints.workspace = true

Create crates/core/src/lib.rs:
- pub mod error;

Create crates/storage/Cargo.toml:
- name = "cherry2k-storage"
- version.workspace = true, edition.workspace = true
- dependencies: cherry2k-core = { path = "../core" }, thiserror.workspace = true
- lints.workspace = true

Create crates/storage/src/lib.rs:
- // Storage layer - implementation coming in Phase 3

Create crates/cli/Cargo.toml:
- name = "cherry2k"
- version.workspace = true, edition.workspace = true
- dependencies: cherry2k-core = { path = "../core" }, cherry2k-storage = { path = "../storage" }
- dependencies: tokio.workspace = true, anyhow.workspace = true, tracing.workspace = true, tracing-subscriber.workspace = true
- lints.workspace = true
- [[bin]] name = "cherry2k", path = "src/main.rs"

Create crates/cli/src/main.rs:
- Minimal main() that just prints "cherry2k v0.1.0"
- use tracing_subscriber for basic logging setup

Create rustfmt.toml:
- max_width = 100
- edition = "2021"

Create clippy.toml:
- cognitive-complexity-threshold = 25

Create .gitignore:
- /target
- Cargo.lock (NO - we want it committed for reproducible builds)
- *.swp, *.swo, .DS_Store
  </action>
  <verify>
Run `cargo check --workspace` - should complete without errors
  </verify>
  <done>All three crates exist and compile as a workspace</done>
</task>

<task type="auto">
  <name>Task 2: Define core error types with thiserror</name>
  <files>crates/core/src/error.rs</files>
  <action>
Create comprehensive error types for Phase 1 and future phases:

```rust
use thiserror::Error;
use std::path::PathBuf;

/// Errors from AI provider operations
#[derive(Debug, Error)]
pub enum ProviderError {
    #[error("API request failed: {0}")]
    RequestFailed(#[from] reqwest::Error),

    #[error("Invalid API key for {provider}")]
    InvalidApiKey { provider: String },

    #[error("Rate limited by {provider}, retry after {retry_after_secs} seconds")]
    RateLimited { provider: String, retry_after_secs: u64 },

    #[error("Provider {provider} is unavailable: {reason}")]
    Unavailable { provider: String, reason: String },

    #[error("Response parsing failed: {0}")]
    ParseError(String),

    #[error("Streaming interrupted: {0}")]
    StreamInterrupted(String),
}

/// Errors from configuration loading
#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("Configuration file not found at {path}")]
    NotFound { path: PathBuf },

    #[error("Failed to read configuration: {0}")]
    ReadError(#[from] std::io::Error),

    #[error("Invalid configuration format: {0}")]
    ParseError(String),

    #[error("Missing required configuration: {field}")]
    MissingField { field: String },

    #[error("Invalid value for {field}: {reason}")]
    InvalidValue { field: String, reason: String },
}

/// Errors from storage operations
#[derive(Debug, Error)]
pub enum StorageError {
    #[error("Database error: {0}")]
    Database(String),

    #[error("Migration failed: {0}")]
    Migration(String),

    #[error("Conversation not found: {id}")]
    ConversationNotFound { id: String },

    #[error("Session not found: {id}")]
    SessionNotFound { id: String },
}

/// Errors from command execution (Phase 6)
#[derive(Debug, Error)]
pub enum CommandError {
    #[error("Command execution denied by user")]
    UserDenied,

    #[error("Command blocked for safety: {reason}")]
    Blocked { reason: String },

    #[error("Command execution failed: {0}")]
    ExecutionFailed(String),

    #[error("Command timed out after {timeout_secs} seconds")]
    Timeout { timeout_secs: u64 },
}
```

Note: reqwest is not yet a dependency, so temporarily comment out the `#[from] reqwest::Error` line or make it a String for now. Add TODO comment to restore when reqwest is added in Phase 2.

Update crates/core/src/lib.rs to export the error module publicly.
  </action>
  <verify>
Run `cargo check -p cherry2k-core` - should compile without warnings
Run `cargo doc -p cherry2k-core --no-deps` - docs should generate
  </verify>
  <done>Error types defined with clear, actionable messages; all variants have descriptive #[error] attributes</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cargo check --workspace` passes
2. `cargo clippy --workspace -- -D warnings` passes (no warnings)
3. `cargo fmt --check` passes
4. Three crates visible: cherry2k-core, cherry2k-storage, cherry2k
5. Error types exist in crates/core/src/error.rs with ProviderError, ConfigError, StorageError, CommandError
</verification>

<success_criteria>
- Workspace compiles with `cargo check --workspace`
- No clippy warnings with `cargo clippy --workspace -- -D warnings`
- Error types are public exports from cherry2k-core
- Code follows rustfmt style (cargo fmt --check passes)
- Crate structure matches ARCHITECTURE.md specification
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-safety/01-01-SUMMARY.md`
</output>
